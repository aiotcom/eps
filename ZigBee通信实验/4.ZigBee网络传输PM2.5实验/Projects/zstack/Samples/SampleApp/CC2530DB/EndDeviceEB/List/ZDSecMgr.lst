###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         18/Dec/2020  11:23:30 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Components\stack\zdo\ZDS #
#                          ecMgr.c                                            #
#    Command line       =  -f C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ #
#                          —È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Sampl #
#                          es\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wE #
#                          ndev.cfg (-DCPU32MHZ -DROOT=__near_func            #
#                          -DBLINK_LEDS) -f C:\Users\Administrator\Desktop\ep #
#                          s\ZigBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Project #
#                          s\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools #
#                          \CC2530DB\f8wConfig.cfg (-DSECURE=0                #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFF11                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Components\stack\zdo\ZDS #
#                          ecMgr.c -D NWK_AUTO_POLL -D ZTOOL_P1 -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈  #
#                          µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samp #
#                          les\SampleApp\CC2530DB\EndDeviceEB\List\ -lA       #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\EndDeviceEB\List\               #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\EndDeviceEB\Obj\ -e             #
#                          --no_unroll --no_inline --no_tbaa --debug          #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I C:\Users\Administrator\Des #
#                          ktop\eps\ZigBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\ -I     #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\SOURCE\ -I                   #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\ -I     #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\   #
#                          -I C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ #
#                          —È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Sampl #
#                          es\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HA #
#                          L\INCLUDE\ -I C:\Users\Administrator\Desktop\eps\Z #
#                          igBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\TARGET\CC2530EB\ -I                   #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\ #
#                          MCU\CCSOC\ -I C:\Users\Administrator\Desktop\eps\Z #
#                          igBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\INCLUDE\ -I                          #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK #
#                          \AF\ -I C:\Users\Administrator\Desktop\eps\ZigBeeÕ #
#                          ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\STACK\NWK\ -I C:\Users\Administrator\Desktop\ep #
#                          s\ZigBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Project #
#                          s\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\ -I                          #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK #
#                          \SAPI\ -I C:\Users\Administrator\Desktop\eps\ZigBe #
#                          eÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\STACK\SYS\ -I C:\Users\Administrator\Desktop\ #
#                          eps\ZigBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\ #
#                          ..\COMPONENTS\STACK\ZDO\ -I                        #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ #
#                          F8W\ -I C:\Users\Administrator\Desktop\eps\ZigBeeÕ #
#                          ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\ZMAC\ -I C:\Users\Administrator\Desktop\eps\Zig #
#                          BeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\SERVICES\SADDR\ -I                          #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVI #
#                          CES\SDATA\ -I C:\Users\Administrator\Desktop\eps\Z #
#                          igBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\INCLUDE\ -I                           #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\H #
#                          IGH_LEVEL\ -I C:\Users\Administrator\Desktop\eps\Z #
#                          igBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\ -I                   #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\L #
#                          OW_LEVEL\srf04\SINGLE_CHIP\ -I                     #
#                          C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HARDW #
#                          ARE\ -Om                                           #
#    List file          =  C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\EndDeviceEB\List\ZDSecMgr.lst   #
#    Object file        =  C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\ #
#                          4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\EndDeviceEB\Obj\ZDSecMgr.r51    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\eps\ZigBeeÕ®–≈ µ—È\4.ZigBeeÕ¯¬Á¥´ ‰PM2.5 µ—È\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-01-08 13:29:59 -0800 (Fri, 08 Jan 2010) $
      4            Revision:       $Revision: 21465 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED ìAS ISî WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          
    123          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    124            // The number of times the frame counter can change before
    125            // saving to NV
    126            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    127          #endif
    128          
    129          /******************************************************************************
    130           * TYPEDEFS
    131           */
    132          typedef struct
    133          {
    134            uint8 extAddr[Z_EXTADDR_LEN];
    135            uint8 key[SEC_KEY_LEN];
    136          } ZDSecMgrPreConfigData_t;
    137          
    138          typedef struct
    139          {
    140            uint16 ami;
    141            uint8  key[SEC_KEY_LEN];
    142          } ZDSecMgrMasterKeyData_t;
    143          
    144          //should match APSME_LinkKeyData_t;
    145          typedef struct
    146          {
    147            uint8               key[SEC_KEY_LEN];
    148            APSME_LinkKeyData_t apsmelkd;
    149          } ZDSecMgrLinkKeyData_t;
    150          
    151          typedef struct
    152          {
    153            uint16                ami;
    154            ZDSecMgrLinkKeyData_t lkd;
    155            ZDSecMgr_Authentication_Option authenticateOption;
    156          } ZDSecMgrEntry_t;
    157          
    158          typedef struct
    159          {
    160            ZDSecMgrEntry_t* entry;
    161            uint16           parentAddr;
    162            uint8            secure;
    163            uint8            state;
    164            uint8            cntr;
    165            //uint8          next;
    166          } ZDSecMgrCtrl_t;
    167          
    168          typedef struct
    169          {
    170            uint16          nwkAddr;
    171            uint8*          extAddr;
    172            uint16          parentAddr;
    173            uint8           secure;
    174            uint8           devStatus;
    175            ZDSecMgrCtrl_t* ctrl;
    176          } ZDSecMgrDevice_t;
    177          
    178          /******************************************************************************
    179           * LOCAL VARIABLES
    180           */
    181          #if 0 // Taken out because the following functionality is only used for test
    182                // purpose. A more efficient (above) way is used. It can be put
    183                // back in if customers request for a white/black list feature.
    184          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    185          {
    186            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    187            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    188            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    189          };
    190          #endif
    191          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    193            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    194          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    195          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    196            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    197             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    198          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    199          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    200          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    201          
    202          //devtag.pro.security - remove this
    203          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    204          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    205          {
    206            //---------------------------------------------------------------------------
    207            // DEVICE A
    208            //---------------------------------------------------------------------------
    209            {
    210              // extAddr
    211              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    212          
    213              // key
    214              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    215               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    216            },
    217            //---------------------------------------------------------------------------
    218            // DEVICE B
    219            //---------------------------------------------------------------------------
    220            {
    221              // extAddr
    222              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    223          
    224              // key
    225              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    226               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    227            },
    228            //---------------------------------------------------------------------------
    229            // DEVICE C
    230            //---------------------------------------------------------------------------
    231            {
    232              // extAddr
    233              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    234          
    235              // key
    236              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    237               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    238            },
    239          };
    240          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    243          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    244          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    245          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    246          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    247          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    248          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    249          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    250          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    251          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    252          
    253          /******************************************************************************
    254           * PRIVATE FUNCTIONS
    255           *
    256           *   ZDSecMgrMasterKeyInit
    257           *   ZDSecMgrAddrStore
    258           *   ZDSecMgrExtAddrStore
    259           *   ZDSecMgrExtAddrLookup
    260           *   ZDSecMgrMasterKeyLookup
    261           *   ZDSecMgrMasterKeyStore
    262           *   ZDSecMgrEntryInit
    263           *   ZDSecMgrEntryLookup
    264           *   ZDSecMgrEntryLookupAMI
    265           *   ZDSecMgrEntryLookupExt
    266           *   ZDSecMgrEntryFree
    267           *   ZDSecMgrEntryNew
    268           *   ZDSecMgrCtrlInit
    269           *   ZDSecMgrCtrlRelease
    270           *   ZDSecMgrCtrlLookup
    271           *   ZDSecMgrCtrlSet
    272           *   ZDSecMgrCtrlAdd
    273           *   ZDSecMgrCtrlTerm
    274           *   ZDSecMgrCtrlReset
    275           *   ZDSecMgrMasterKeyLoad
    276           *   ZDSecMgrAppKeyGet
    277           *   ZDSecMgrAppKeyReq
    278           *   ZDSecMgrEstablishKey
    279           *   ZDSecMgrSendMasterKey
    280           *   ZDSecMgrSendNwkKey
    281           *   ZDSecMgrDeviceEntryRemove
    282           *   ZDSecMgrDeviceEntryAdd
    283           *   ZDSecMgrDeviceCtrlHandler
    284           *   ZDSecMgrDeviceCtrlSetup
    285           *   ZDSecMgrDeviceCtrlUpdate
    286           *   ZDSecMgrDeviceRemove
    287           *   ZDSecMgrDeviceValidateSKKE
    288           *   ZDSecMgrDeviceValidateRM
    289           *   ZDSecMgrDeviceValidateCM
    290           *   ZDSecMgrDeviceValidate
    291           *   ZDSecMgrDeviceJoin
    292           *   ZDSecMgrDeviceJoinDirect
    293           *   ZDSecMgrDeviceJoinFwd
    294           *   ZDSecMgrDeviceNew
    295           *   ZDSecMgrAssocDeviceAuth
    296           *   ZDSecMgrAuthInitiate
    297           *   ZDSecMgrAuthNwkKey
    298           *   APSME_TCLinkKeyInit
    299           *   APSME_IsDefaultTCLK
    300           */
    301          //-----------------------------------------------------------------------------
    302          // master key data
    303          //-----------------------------------------------------------------------------
    304          void ZDSecMgrMasterKeyInit( void );
    305          
    306          //-----------------------------------------------------------------------------
    307          // address management
    308          //-----------------------------------------------------------------------------
    309          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    310          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    311          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    312          
    313          //-----------------------------------------------------------------------------
    314          // MASTER key data
    315          //-----------------------------------------------------------------------------
    316          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    317          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    318          
    319          //-----------------------------------------------------------------------------
    320          // entry data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrEntryInit(uint8 state);
    323          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    324          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    325          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    326          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    327          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    328          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    329          
    330          //-----------------------------------------------------------------------------
    331          // control data
    332          //-----------------------------------------------------------------------------
    333          void ZDSecMgrCtrlInit( void );
    334          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    335          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    336          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    337                                ZDSecMgrEntry_t*  entry,
    338                                ZDSecMgrCtrl_t*   ctrl );
    339          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    340          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    341          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    342                                       ZDSecMgrEntry_t*  entry );
    343          
    344          //-----------------------------------------------------------------------------
    345          // key support
    346          //-----------------------------------------------------------------------------
    347          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    348          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    349                                       uint8*  initExtAddr,
    350                                       uint16  partNwkAddr,
    351                                       uint8*  partExtAddr,
    352                                       uint8** key,
    353                                       uint8*  keyType );
    354          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    355          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    356          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    357          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    358          
    359          //-----------------------------------------------------------------------------
    360          // device entry
    361          //-----------------------------------------------------------------------------
    362          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    363          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    364          #if defined NV_RESTORE
    365          static void ZDSecMgrWriteNV(void);
    366          static void ZDSecMgrRestoreFromNV(void);
    367          #endif
    368          
    369          //-----------------------------------------------------------------------------
    370          // device control
    371          //-----------------------------------------------------------------------------
    372          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    373          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    374          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    375          
    376          //-----------------------------------------------------------------------------
    377          // device management
    378          //-----------------------------------------------------------------------------
    379          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    382          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    383          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    384          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    385          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    386          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    387          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    388          
    389          //-----------------------------------------------------------------------------
    390          // association management
    391          //-----------------------------------------------------------------------------
    392          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    393          
    394          //-----------------------------------------------------------------------------
    395          // authentication management
    396          //-----------------------------------------------------------------------------
    397          void ZDSecMgrAuthInitiate( uint8* responder );
    398          void ZDSecMgrAuthNwkKey( void );
    399          
    400          //-----------------------------------------------------------------------------
    401          // APSME function
    402          //-----------------------------------------------------------------------------
    403          void APSME_TCLinkKeyInit( void );
    404          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    405          
    406          /******************************************************************************
    407           * @fn          ZDSecMgrMasterKeyInit                     ]
    408           *
    409           * @brief       Initialize master key data.
    410           *
    411           * @param       none
    412           *
    413           * @return      none
    414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    415          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    416          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    417            uint16 index;
    418            uint16 size;
    419          
    420            // allocate MASTER key data
    421            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    422          
    423            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV     R2,#0x36
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000E   EA           MOV     A,R2
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   EB           MOV     A,R3
   \   000012   F0           MOVX    @DPTR,A
    424          
    425            // initialize MASTER key data
    426            if ( ZDSecMgrMasterKeyData != NULL )
   \   000013   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   49           ORL     A,R1
   \   00001D   603D         JZ      ??ZDSecMgrMasterKeyInit_0
    427            {
    428              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   00001F   7800         MOV     R0,#0x0
   \   000021   7900         MOV     R1,#0x0
   \   000023   802E         SJMP    ??ZDSecMgrMasterKeyInit_1
    429              {
    430                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000025   E8           MOV     A,R0
   \   000026   FA           MOV     R2,A
   \   000027   E9           MOV     A,R1
   \   000028   FB           MOV     R3,A
   \   000029   EA           MOV     A,R2
   \   00002A   75F012       MOV     B,#0x12
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   ACF0         MOV     R4,B
   \   000031   75F012       MOV     B,#0x12
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   2C           ADD     A,R4
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   8C82         MOV     DPL,R4
   \   000043   F583         MOV     DPH,A
   \   000045   74FE         MOV     A,#-0x2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   04           INC     A
   \   00004A   F0           MOVX    @DPTR,A
    431              }
   \   00004B   E8           MOV     A,R0
   \   00004C   2401         ADD     A,#0x1
   \   00004E   08           INC     R0
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   F9           MOV     R1,A
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000053   C3           CLR     C
   \   000054   E8           MOV     A,R0
   \   000055   9403         SUBB    A,#0x3
   \   000057   E9           MOV     A,R1
   \   000058   9400         SUBB    A,#0x0
   \   00005A   40C9         JC      ??ZDSecMgrMasterKeyInit_2
    432            }
    433          }
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00005C   D083         POP     DPH
   \   00005E   D082         POP     DPL
   \   000060   02....       LJMP    ?BRET
    434          //devtag.pro.security
    435          #if 0
    436          void ZDSecMgrMasterKeyInit( void )
    437          {
    438            uint16         index;
    439            uint16         size;
    440            AddrMgrEntry_t entry;
    441          
    442          
    443            // allocate MASTER key data
    444            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    445          
    446            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    447          
    448            // initialize MASTER key data
    449            if ( ZDSecMgrMasterKeyData != NULL )
    450            {
    451              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    452              {
    453                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    454              }
    455          
    456              // check if preconfigured keys are enabled
    457              //-------------------------------------------------------------------------
    458              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    459              //-------------------------------------------------------------------------
    460              if ( zgPreConfigKeys == TRUE )
    461              {
    462                // sync configured data
    463                entry.user = ADDRMGR_USER_SECURITY;
    464          
    465                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    466                {
    467                  // check for Address Manager entry
    468                  AddrMgrExtAddrSet( entry.extAddr,
    469                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    470          
    471                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    472                  {
    473                    // update Address Manager
    474                    AddrMgrEntryUpdate( &entry );
    475                  }
    476          
    477                  if ( entry.index != INVALID_NODE_ADDR )
    478                  {
    479                    // sync MASTER keys with Address Manager index
    480                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    481          
    482                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    483                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    484                  }
    485                }
    486              }
    487              //-------------------------------------------------------------------------
    488              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    489              //-------------------------------------------------------------------------
    490            }
    491          }
    492          #endif
    493          
    494          /******************************************************************************
    495           * @fn          ZDSecMgrAddrStore
    496           *
    497           * @brief       Store device addresses.
    498           *
    499           * @param       nwkAddr - [in] NWK address
    500           * @param       extAddr - [in] EXT address
    501           * @param       ami     - [out] Address Manager index
    502           *
    503           * @return      ZStatus_t
    504           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    505          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    506          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   FE           MOV     R6,A
   \   000016   E9           MOV     A,R1
   \   000017   FF           MOV     R7,A
    507            ZStatus_t      status;
    508            AddrMgrEntry_t entry;
    509          
    510          
    511            // add entry
    512            entry.user    = ADDRMGR_USER_SECURITY;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   7402         MOV     A,#0x2
   \   000020   F0           MOVX    @DPTR,A
    513            entry.nwkAddr = nwkAddr;
   \   000021   14           DEC     A
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   EA           MOV     A,R2
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   EB           MOV     A,R3
   \   000029   F0           MOVX    @DPTR,A
    514            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00002A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002A   7403         MOV     A,#0x3
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrSet?relay
    515          
    516            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000036                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000043   E9           MOV     A,R1
   \   000044   6401         XRL     A,#0x1
   \   000046   7017         JNZ     ??ZDSecMgrAddrStore_0
    517            {
    518              // return successful results
    519              *ami   = entry.index;
   \   000048   740B         MOV     A,#0xb
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F8           MOV     R0,A
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F9           MOV     R1,A
   \   000052   8E82         MOV     DPL,R6
   \   000054   8F83         MOV     DPH,R7
   \   000056   E8           MOV     A,R0
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   F0           MOVX    @DPTR,A
    520              status = ZSuccess;
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   8015         SJMP    ??ZDSecMgrAddrStore_1
    521            }
    522            else
    523            {
    524              // return failed results
    525              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00005F   740B         MOV     A,#0xb
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F8           MOV     R0,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   E8           MOV     A,R0
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   E9           MOV     A,R1
   \   000071   F0           MOVX    @DPTR,A
    526              status = ZNwkUnknownDevice;
   \   000072   79C8         MOV     R1,#-0x38
    527            }
    528          
    529            return status;
   \                     ??ZDSecMgrAddrStore_1:
   \   000074   740D         MOV     A,#0xd
   \   000076   12....       LCALL   ?DEALLOC_XSTACK8
   \   000079   7F01         MOV     R7,#0x1
   \   00007B   02....       LJMP    ?BANKED_LEAVE_XDATA
    530          }
    531          
    532          /******************************************************************************
    533           * @fn          ZDSecMgrExtAddrStore
    534           *
    535           * @brief       Store EXT address.
    536           *
    537           * @param       extAddr - [in] EXT address
    538           * @param       ami     - [out] Address Manager index
    539           *
    540           * @return      ZStatus_t
    541           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    543          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   FE           MOV     R6,A
   \   000016   E9           MOV     A,R1
   \   000017   FF           MOV     R7,A
    544            ZStatus_t      status;
    545            AddrMgrEntry_t entry;
    546          
    547          
    548            // add entry
    549            entry.user    = ADDRMGR_USER_SECURITY;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   7402         MOV     A,#0x2
   \   000020   F0           MOVX    @DPTR,A
    550            entry.nwkAddr = nwkAddr;
   \   000021   14           DEC     A
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   EA           MOV     A,R2
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   EB           MOV     A,R3
   \   000029   F0           MOVX    @DPTR,A
    551            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00002A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002A   7403         MOV     A,#0x3
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrSet?relay
    552          
    553            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000036                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000043   E9           MOV     A,R1
   \   000044   6401         XRL     A,#0x1
   \   000046   7017         JNZ     ??ZDSecMgrExtAddrStore_0
    554            {
    555              // return successful results
    556              *ami   = entry.index;
   \   000048   740B         MOV     A,#0xb
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F8           MOV     R0,A
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F9           MOV     R1,A
   \   000052   8E82         MOV     DPL,R6
   \   000054   8F83         MOV     DPH,R7
   \   000056   E8           MOV     A,R0
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   F0           MOVX    @DPTR,A
    557              status = ZSuccess;
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   8015         SJMP    ??ZDSecMgrExtAddrStore_1
    558            }
    559            else
    560            {
    561              // return failed results
    562              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00005F   740B         MOV     A,#0xb
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F8           MOV     R0,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   E8           MOV     A,R0
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   E9           MOV     A,R1
   \   000071   F0           MOVX    @DPTR,A
    563              status = ZNwkUnknownDevice;
   \   000072   79C8         MOV     R1,#-0x38
    564            }
    565          
    566            return status;
   \                     ??ZDSecMgrExtAddrStore_1:
   \   000074   740D         MOV     A,#0xd
   \   000076   12....       LCALL   ?DEALLOC_XSTACK8
   \   000079   7F01         MOV     R7,#0x1
   \   00007B   02....       LJMP    ?BANKED_LEAVE_XDATA
    567          }
    568          
    569          /******************************************************************************
    570           * @fn          ZDSecMgrExtAddrLookup
    571           *
    572           * @brief       Lookup index for specified EXT address.
    573           *
    574           * @param       extAddr - [in] EXT address
    575           * @param       ami     - [out] Address Manager index
    576           *
    577           * @return      ZStatus_t
    578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    579          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    580          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    581            ZStatus_t      status;
    582            AddrMgrEntry_t entry;
    583          
    584          
    585            // lookup entry
    586            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    587            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   ??AddrMgrExtAddrSet?relay
    588          
    589            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   7017         JNZ     ??ZDSecMgrExtAddrLookup_0
    590            {
    591              // return successful results
    592              *ami   = entry.index;
   \   000039   740B         MOV     A,#0xb
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F8           MOV     R0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F9           MOV     R1,A
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   E8           MOV     A,R0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E9           MOV     A,R1
   \   00004B   F0           MOVX    @DPTR,A
    593              status = ZSuccess;
   \   00004C   7900         MOV     R1,#0x0
   \   00004E   8015         SJMP    ??ZDSecMgrExtAddrLookup_1
    594            }
    595            else
    596            {
    597              // return failed results
    598              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000050   740B         MOV     A,#0xb
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   8E82         MOV     DPL,R6
   \   00005C   8F83         MOV     DPH,R7
   \   00005E   E8           MOV     A,R0
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   \   000061   E9           MOV     A,R1
   \   000062   F0           MOVX    @DPTR,A
    599              status = ZNwkUnknownDevice;
   \   000063   79C8         MOV     R1,#-0x38
    600            }
    601          
    602            return status;
   \                     ??ZDSecMgrExtAddrLookup_1:
   \   000065   740D         MOV     A,#0xd
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006A   7F01         MOV     R7,#0x1
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
    603          }
    604          
    605          /******************************************************************************
    606           * @fn          ZDSecMgrMasterKeyLookup
    607           *
    608           * @brief       Lookup MASTER key for specified address index.
    609           *
    610           * @param       ami - [in] Address Manager index
    611           * @param       key - [out] valid MASTER key
    612           *
    613           * @return      ZStatus_t
    614           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    615          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    616          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    617            ZStatus_t status;
    618            uint16    index;
    619          
    620          
    621            // initialize results
    622            *key   = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    623            status = ZNwkUnknownDevice;
   \   00000D   75..C8       MOV     ?V0 + 0,#-0x38
    624          
    625            // verify data is available
    626            if ( ZDSecMgrMasterKeyData != NULL )
   \   000010   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   605B         JZ      ??ZDSecMgrMasterKeyLookup_0
    627            {
    628              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00001C   7800         MOV     R0,#0x0
   \   00001E   7900         MOV     R1,#0x0
   \   000020   804C         SJMP    ??ZDSecMgrMasterKeyLookup_1
    629              {
    630                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000022   E8           MOV     A,R0
   \   000023   FE           MOV     R6,A
   \   000024   E9           MOV     A,R1
   \   000025   FF           MOV     R7,A
   \   000026   EE           MOV     A,R6
   \   000027   75F012       MOV     B,#0x12
   \   00002A   A4           MUL     AB
   \   00002B   FE           MOV     R6,A
   \   00002C   85F0..       MOV     ?V0 + 1,B
   \   00002F   75F012       MOV     B,#0x12
   \   000032   EF           MOV     A,R7
   \   000033   A4           MUL     AB
   \   000034   25..         ADD     A,?V0 + 1
   \   000036   FF           MOV     R7,A
   \   000037   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   2E           ADD     A,R6
   \   00003C   FE           MOV     R6,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   3F           ADDC    A,R7
   \   000040   FF           MOV     R7,A
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   E0           MOVX    A,@DPTR
   \   000046   6A           XRL     A,R2
   \   000047   7003         JNZ     ??ZDSecMgrMasterKeyLookup_3
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   6B           XRL     A,R3
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   00004C   7018         JNZ     ??ZDSecMgrMasterKeyLookup_4
    631                {
    632                  // return successful results
    633                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   00004E   EE           MOV     A,R6
   \   00004F   2402         ADD     A,#0x2
   \   000051   F8           MOV     R0,A
   \   000052   EF           MOV     A,R7
   \   000053   3400         ADDC    A,#0x0
   \   000055   F9           MOV     R1,A
   \   000056   8C82         MOV     DPL,R4
   \   000058   8D83         MOV     DPH,R5
   \   00005A   E8           MOV     A,R0
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   E9           MOV     A,R1
   \   00005E   F0           MOVX    @DPTR,A
    634                  status = ZSuccess;
   \   00005F   75..00       MOV     ?V0 + 0,#0x0
    635          
    636                  // break from loop
    637                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   000062   7803         MOV     R0,#0x3
   \   000064   7900         MOV     R1,#0x0
    638                }
    639              }
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   000066   E8           MOV     A,R0
   \   000067   2401         ADD     A,#0x1
   \   000069   08           INC     R0
   \   00006A   E9           MOV     A,R1
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F9           MOV     R1,A
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   00006E   C3           CLR     C
   \   00006F   E8           MOV     A,R0
   \   000070   9403         SUBB    A,#0x3
   \   000072   E9           MOV     A,R1
   \   000073   9400         SUBB    A,#0x0
   \   000075   40AB         JC      ??ZDSecMgrMasterKeyLookup_2
    640            }
    641          
    642            return status;
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000077   A9..         MOV     R1,?V0 + 0
   \   000079   7F02         MOV     R7,#0x2
   \   00007B   02....       LJMP    ?BANKED_LEAVE_XDATA
    643          }
    644          
    645          /******************************************************************************
    646           * @fn          ZDSecMgrMasterKeyStore
    647           *
    648           * @brief       Store MASTER key for specified address index.
    649           *
    650           * @param       ami - [in] Address Manager index
    651           * @param       key - [in] valid key to store
    652           *
    653           * @return      ZStatus_t
    654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    655          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    656          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    657            ZStatus_t status;
    658            uint16    index;
    659            uint8*    entry;
    660          
    661          
    662            // initialize results
    663            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
    664          
    665            // verify data is available
    666            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FA           MOV     R2,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FB           MOV     R3,A
   \   000017   EA           MOV     A,R2
   \   000018   4B           ORL     A,R3
   \   000019   7003         JNZ     $+5
   \   00001B   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    667            {
    668              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00001E   7C00         MOV     R4,#0x0
   \   000020   7D00         MOV     R5,#0x0
   \   000022   8017         SJMP    ??ZDSecMgrMasterKeyStore_1
    669              {
    670                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
    671                {
    672                  // store EXT address index
    673                  ZDSecMgrMasterKeyData[index].ami = ami;
    674          
    675                  entry = ZDSecMgrMasterKeyData[index].key;
    676          
    677                  if ( key != NULL )
    678                  {
    679                    osal_memcpy( entry, key,  SEC_KEY_LEN );
    680                  }
    681                  else
    682                  {
    683                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   000024                ; Setup parameters for call to function osal_memset
   \   000024   7C10         MOV     R4,#0x10
   \   000026   7D00         MOV     R5,#0x0
   \   000028   7900         MOV     R1,#0x0
   \   00002A   12....       LCALL   ??osal_memset?relay
    684                  }
    685          
    686                  // return successful results
    687                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00002D   7900         MOV     R1,#0x0
    688          
    689                  // break from loop
    690                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   00002F   7C03         MOV     R4,#0x3
   \   000031   7D00         MOV     R5,#0x0
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000033   EC           MOV     A,R4
   \   000034   2401         ADD     A,#0x1
   \   000036   0C           INC     R4
   \   000037   ED           MOV     A,R5
   \   000038   3400         ADDC    A,#0x0
   \   00003A   FD           MOV     R5,A
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00003B   C3           CLR     C
   \   00003C   EC           MOV     A,R4
   \   00003D   9403         SUBB    A,#0x3
   \   00003F   ED           MOV     A,R5
   \   000040   9400         SUBB    A,#0x0
   \   000042   506D         JNC     ??ZDSecMgrMasterKeyStore_0
   \   000044   EC           MOV     A,R4
   \   000045   FA           MOV     R2,A
   \   000046   ED           MOV     A,R5
   \   000047   FB           MOV     R3,A
   \   000048   EA           MOV     A,R2
   \   000049   75F012       MOV     B,#0x12
   \   00004C   A4           MUL     AB
   \   00004D   FA           MOV     R2,A
   \   00004E   A8F0         MOV     R0,B
   \   000050   75F012       MOV     B,#0x12
   \   000053   EB           MOV     A,R3
   \   000054   A4           MUL     AB
   \   000055   28           ADD     A,R0
   \   000056   FB           MOV     R3,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   2A           ADD     A,R2
   \   00005C   F5..         MOV     ?V0 + 2,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   3B           ADDC    A,R3
   \   000061   F5..         MOV     ?V0 + 3,A
   \   000063   85..82       MOV     DPL,?V0 + 2
   \   000066   F583         MOV     DPH,A
   \   000068   E0           MOVX    A,@DPTR
   \   000069   64FE         XRL     A,#0xfe
   \   00006B   7003         JNZ     ??ZDSecMgrMasterKeyStore_5
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F4           CPL     A
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   000070   70C1         JNZ     ??ZDSecMgrMasterKeyStore_4
   \   000072   85..82       MOV     DPL,?V0 + 2
   \   000075   85..83       MOV     DPH,?V0 + 3
   \   000078   E5..         MOV     A,?V0 + 0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E5..         MOV     A,?V0 + 1
   \   00007E   F0           MOVX    @DPTR,A
   \   00007F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2A           ADD     A,R2
   \   000084   F8           MOV     R0,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   3B           ADDC    A,R3
   \   000088   8882         MOV     DPL,R0
   \   00008A   F583         MOV     DPH,A
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   AA82         MOV     R2,DPL
   \   000090   AB83         MOV     R3,DPH
   \   000092   EE           MOV     A,R6
   \   000093   4F           ORL     A,R7
   \   000094   608E         JZ      ??ZDSecMgrMasterKeyStore_2
   \   000096                ; Setup parameters for call to function osal_memcpy
   \   000096   8E..         MOV     ?V0 + 4,R6
   \   000098   8F..         MOV     ?V0 + 5,R7
   \   00009A   75..00       MOV     ?V0 + 6,#0x0
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000A2   7C10         MOV     R4,#0x10
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   12....       LCALL   ??osal_memcpy?relay
   \   0000A9   7403         MOV     A,#0x3
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   02....       LJMP    ??ZDSecMgrMasterKeyStore_3 & 0xFFFF
    691                }
    692              }
    693            }
    694          
    695            return status;
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   0000B1   7F07         MOV     R7,#0x7
   \   0000B3   02....       LJMP    ?BANKED_LEAVE_XDATA
    696          }
    697          
    698          /******************************************************************************
    699           * @fn          ZDSecMgrEntryInit
    700           *
    701           * @brief       Initialize entry sub module
    702           *
    703           * @param       state - device initialization state
    704           *
    705           * @return      none
    706           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    707          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    708          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    709            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   E8           MOV     A,R0
   \   00000D   49           ORL     A,R1
   \   00000E   7058         JNZ     ??ZDSecMgrEntryInit_0
    710            {
    711              uint16 index;
    712          
    713              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000010                ; Setup parameters for call to function osal_mem_alloc
   \   000010   7A57         MOV     R2,#0x57
   \   000012   7B00         MOV     R3,#0x0
   \   000014   12....       LCALL   ??osal_mem_alloc?relay
   \   000017   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001A   EA           MOV     A,R2
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   EB           MOV     A,R3
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   E8           MOV     A,R0
   \   000028   49           ORL     A,R1
   \   000029   603D         JZ      ??ZDSecMgrEntryInit_0
    714              {
    715                return;
    716              }
    717          
    718              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   00002B   7800         MOV     R0,#0x0
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   802E         SJMP    ??ZDSecMgrEntryInit_1
    719              {
    720                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_2:
   \   000031   E8           MOV     A,R0
   \   000032   FA           MOV     R2,A
   \   000033   E9           MOV     A,R1
   \   000034   FB           MOV     R3,A
   \   000035   EA           MOV     A,R2
   \   000036   75F01D       MOV     B,#0x1d
   \   000039   A4           MUL     AB
   \   00003A   FA           MOV     R2,A
   \   00003B   ACF0         MOV     R4,B
   \   00003D   75F01D       MOV     B,#0x1d
   \   000040   EB           MOV     A,R3
   \   000041   A4           MUL     AB
   \   000042   2C           ADD     A,R4
   \   000043   FB           MOV     R3,A
   \   000044   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000047   E0           MOVX    A,@DPTR
   \   000048   2A           ADD     A,R2
   \   000049   FC           MOV     R4,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   3B           ADDC    A,R3
   \   00004D   8C82         MOV     DPL,R4
   \   00004F   F583         MOV     DPH,A
   \   000051   74FE         MOV     A,#-0x2
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   04           INC     A
   \   000056   F0           MOVX    @DPTR,A
    721              }
   \   000057   E8           MOV     A,R0
   \   000058   2401         ADD     A,#0x1
   \   00005A   08           INC     R0
   \   00005B   E9           MOV     A,R1
   \   00005C   3400         ADDC    A,#0x0
   \   00005E   F9           MOV     R1,A
   \                     ??ZDSecMgrEntryInit_1:
   \   00005F   C3           CLR     C
   \   000060   E8           MOV     A,R0
   \   000061   9403         SUBB    A,#0x3
   \   000063   E9           MOV     A,R1
   \   000064   9400         SUBB    A,#0x0
   \   000066   40C9         JC      ??ZDSecMgrEntryInit_2
   \                     ??ZDSecMgrEntryInit_0:
   \   000068   D083         POP     DPH
   \   00006A   D082         POP     DPL
   \   00006C   02....       LJMP    ?BRET
    722            }
    723          
    724          #if defined NV_RESTORE
    725            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    726            {
    727              ZDSecMgrRestoreFromNV();
    728            }
    729          #else
    730            (void)state;
    731          #endif
    732          }
    733          
    734          /******************************************************************************
    735           * @fn          ZDSecMgrEntryLookup
    736           *
    737           * @brief       Lookup entry index using specified NWK address.
    738           *
    739           * @param       nwkAddr - [in] NWK address
    740           * @param       entry   - [out] valid entry
    741           *
    742           * @return      ZStatus_t
    743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    744          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    745          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    746            ZStatus_t      status;
    747            uint16         index;
    748            AddrMgrEntry_t addrMgrEntry;
    749          
    750          
    751            // initialize results
    752            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    753            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    754          
    755            // verify data is available
    756            if ( ZDSecMgrEntries != NULL )
   \   000019   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   7003         JNZ     $+5
   \   000025   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    757            {
    758              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   7402         MOV     A,#0x2
   \   000030   F0           MOVX    @DPTR,A
    759              addrMgrEntry.nwkAddr = nwkAddr;
   \   000031   14           DEC     A
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   F0           MOVX    @DPTR,A
    760          
    761              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   00003A                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   AA82         MOV     R2,DPL
   \   000042   AB83         MOV     R3,DPH
   \   000044   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000047   E9           MOV     A,R1
   \   000048   6401         XRL     A,#0x1
   \   00004A   705F         JNZ     ??ZDSecMgrEntryLookup_0
    762              {
    763                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00004C   7800         MOV     R0,#0x0
   \   00004E   7900         MOV     R1,#0x0
   \   000050   8050         SJMP    ??ZDSecMgrEntryLookup_1
    764                {
    765                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_2:
   \   000052   E8           MOV     A,R0
   \   000053   FA           MOV     R2,A
   \   000054   E9           MOV     A,R1
   \   000055   FB           MOV     R3,A
   \   000056   EA           MOV     A,R2
   \   000057   75F01D       MOV     B,#0x1d
   \   00005A   A4           MUL     AB
   \   00005B   FA           MOV     R2,A
   \   00005C   ACF0         MOV     R4,B
   \   00005E   75F01D       MOV     B,#0x1d
   \   000061   EB           MOV     A,R3
   \   000062   A4           MUL     AB
   \   000063   2C           ADD     A,R4
   \   000064   FB           MOV     R3,A
   \   000065   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000068   E0           MOVX    A,@DPTR
   \   000069   2A           ADD     A,R2
   \   00006A   FA           MOV     R2,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   3B           ADDC    A,R3
   \   00006E   FB           MOV     R3,A
   \   00006F   740B         MOV     A,#0xb
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FC           MOV     R4,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   FD           MOV     R5,A
   \   000079   8A82         MOV     DPL,R2
   \   00007B   8B83         MOV     DPH,R3
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   6C           XRL     A,R4
   \   00007F   7003         JNZ     ??ZDSecMgrEntryLookup_3
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_3:
   \   000084   7014         JNZ     ??ZDSecMgrEntryLookup_4
    766                  {
    767                    // return successful results
    768                    *entry = &ZDSecMgrEntries[index];
   \   000086   EA           MOV     A,R2
   \   000087   F8           MOV     R0,A
   \   000088   EB           MOV     A,R3
   \   000089   F9           MOV     R1,A
   \   00008A   8E82         MOV     DPL,R6
   \   00008C   8F83         MOV     DPH,R7
   \   00008E   E8           MOV     A,R0
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   F0           MOVX    @DPTR,A
    769                    status = ZSuccess;
   \   000093   75..00       MOV     ?V0 + 0,#0x0
    770          
    771                    // break from loop
    772                    index = ZDSECMGR_ENTRY_MAX;
   \   000096   7803         MOV     R0,#0x3
   \   000098   7900         MOV     R1,#0x0
    773                  }
    774                }
   \                     ??ZDSecMgrEntryLookup_4:
   \   00009A   E8           MOV     A,R0
   \   00009B   2401         ADD     A,#0x1
   \   00009D   08           INC     R0
   \   00009E   E9           MOV     A,R1
   \   00009F   3400         ADDC    A,#0x0
   \   0000A1   F9           MOV     R1,A
   \                     ??ZDSecMgrEntryLookup_1:
   \   0000A2   C3           CLR     C
   \   0000A3   E8           MOV     A,R0
   \   0000A4   9403         SUBB    A,#0x3
   \   0000A6   E9           MOV     A,R1
   \   0000A7   9400         SUBB    A,#0x0
   \   0000A9   40A7         JC      ??ZDSecMgrEntryLookup_2
    775              }
    776            }
    777          
    778            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   0000AB   A9..         MOV     R1,?V0 + 0
   \   0000AD   740D         MOV     A,#0xd
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   7F02         MOV     R7,#0x2
   \   0000B4   02....       LJMP    ?BANKED_LEAVE_XDATA
    779          }
    780          
    781          /******************************************************************************
    782           * @fn          ZDSecMgrEntryLookupAMI
    783           *
    784           * @brief       Lookup entry using specified address index
    785           *
    786           * @param       ami   - [in] Address Manager index
    787           * @param       entry - [out] valid entry
    788           *
    789           * @return      ZStatus_t
    790           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    791          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    792          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    793            ZStatus_t status;
    794            uint16    index;
    795          
    796          
    797            // initialize results
    798            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    799            status = ZNwkUnknownDevice;
   \   000011   75..C8       MOV     ?V0 + 0,#-0x38
    800          
    801            // verify data is available
    802            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   6057         JZ      ??ZDSecMgrEntryLookupAMI_0
    803            {
    804              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7800         MOV     R0,#0x0
   \   000022   7900         MOV     R1,#0x0
   \   000024   8048         SJMP    ??ZDSecMgrEntryLookupAMI_1
    805              {
    806                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000026   E8           MOV     A,R0
   \   000027   FA           MOV     R2,A
   \   000028   E9           MOV     A,R1
   \   000029   FB           MOV     R3,A
   \   00002A   EA           MOV     A,R2
   \   00002B   75F01D       MOV     B,#0x1d
   \   00002E   A4           MUL     AB
   \   00002F   FA           MOV     R2,A
   \   000030   85F0..       MOV     ?V0 + 1,B
   \   000033   75F01D       MOV     B,#0x1d
   \   000036   EB           MOV     A,R3
   \   000037   A4           MUL     AB
   \   000038   25..         ADD     A,?V0 + 1
   \   00003A   FB           MOV     R3,A
   \   00003B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2A           ADD     A,R2
   \   000040   FA           MOV     R2,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   3B           ADDC    A,R3
   \   000044   FB           MOV     R3,A
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6E           XRL     A,R6
   \   00004B   7003         JNZ     ??ZDSecMgrEntryLookupAMI_3
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000050   7014         JNZ     ??ZDSecMgrEntryLookupAMI_4
    807                {
    808                  // return successful results
    809                  *entry = &ZDSecMgrEntries[index];
   \   000052   EA           MOV     A,R2
   \   000053   F8           MOV     R0,A
   \   000054   EB           MOV     A,R3
   \   000055   F9           MOV     R1,A
   \   000056   8C82         MOV     DPL,R4
   \   000058   8D83         MOV     DPH,R5
   \   00005A   E8           MOV     A,R0
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   E9           MOV     A,R1
   \   00005E   F0           MOVX    @DPTR,A
    810                  status = ZSuccess;
   \   00005F   75..00       MOV     ?V0 + 0,#0x0
    811          
    812                  // break from loop
    813                  index = ZDSECMGR_ENTRY_MAX;
   \   000062   7803         MOV     R0,#0x3
   \   000064   7900         MOV     R1,#0x0
    814                }
    815              }
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000066   E8           MOV     A,R0
   \   000067   2401         ADD     A,#0x1
   \   000069   08           INC     R0
   \   00006A   E9           MOV     A,R1
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F9           MOV     R1,A
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   00006E   C3           CLR     C
   \   00006F   E8           MOV     A,R0
   \   000070   9403         SUBB    A,#0x3
   \   000072   E9           MOV     A,R1
   \   000073   9400         SUBB    A,#0x0
   \   000075   40AF         JC      ??ZDSecMgrEntryLookupAMI_2
    816            }
    817          
    818            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000077   A9..         MOV     R1,?V0 + 0
   \   000079   7F02         MOV     R7,#0x2
   \   00007B   02....       LJMP    ?BANKED_LEAVE_XDATA
    819          }
    820          
    821          /******************************************************************************
    822           * @fn          ZDSecMgrEntryLookupExt
    823           *
    824           * @brief       Lookup entry index using specified EXT address.
    825           *
    826           * @param       extAddr - [in] EXT address
    827           * @param       entry   - [out] valid entry
    828           *
    829           * @return      ZStatus_t
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    832          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    833            ZStatus_t status;
    834            uint16    ami;
    835          
    836          
    837            // initialize results
    838            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    839            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    840          
    841            // lookup address index
    842            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   7015         JNZ     ??ZDSecMgrEntryLookupExt_0
    843            {
    844              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000029                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000029   EE           MOV     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FD           MOV     R5,A
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FA           MOV     R2,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00003B   E9           MOV     A,R1
   \   00003C   F5..         MOV     ?V0 + 0,A
    845            }
    846          
    847            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   00003E   A9..         MOV     R1,?V0 + 0
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   7F01         MOV     R7,#0x1
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
    848          }
    849          
    850          /******************************************************************************
    851           * @fn          ZDSecMgrEntryFree
    852           *
    853           * @brief       Free entry.
    854           *
    855           * @param       entry - [in] valid entry
    856           *
    857           * @return      ZStatus_t
    858           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    859          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    860          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    861            entry->ami = INVALID_NODE_ADDR;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   74FE         MOV     A,#-0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   04           INC     A
   \   00000D   F0           MOVX    @DPTR,A
    862          }
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
    863          
    864          /******************************************************************************
    865           * @fn          ZDSecMgrEntryNew
    866           *
    867           * @brief       Get a new entry.
    868           *
    869           * @param       entry - [out] valid entry
    870           *
    871           * @return      ZStatus_t
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    874          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    875            ZStatus_t status;
    876            uint16    index;
    877          
    878          
    879            // initialize results
    880            *entry = NULL;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    881            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
    882          
    883            // verify data is available
    884            if ( ZDSecMgrEntries != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FC           MOV     R4,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FD           MOV     R5,A
   \   000017   EC           MOV     A,R4
   \   000018   4D           ORL     A,R5
   \   000019   606B         JZ      ??ZDSecMgrEntryNew_0
    885            {
    886              // find available entry
    887              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00001B   7E00         MOV     R6,#0x0
   \   00001D   7F00         MOV     R7,#0x0
   \   00001F   805C         SJMP    ??ZDSecMgrEntryNew_1
    888              {
    889                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_2:
   \   000021   EE           MOV     A,R6
   \   000022   FC           MOV     R4,A
   \   000023   EF           MOV     A,R7
   \   000024   FD           MOV     R5,A
   \   000025   EC           MOV     A,R4
   \   000026   75F01D       MOV     B,#0x1d
   \   000029   A4           MUL     AB
   \   00002A   FC           MOV     R4,A
   \   00002B   A8F0         MOV     R0,B
   \   00002D   75F01D       MOV     B,#0x1d
   \   000030   ED           MOV     A,R5
   \   000031   A4           MUL     AB
   \   000032   28           ADD     A,R0
   \   000033   FD           MOV     R5,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000037   E0           MOVX    A,@DPTR
   \   000038   2C           ADD     A,R4
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   3D           ADDC    A,R5
   \   00003E   F5..         MOV     ?V0 + 1,A
   \   000040   85..82       MOV     DPL,?V0 + 0
   \   000043   F583         MOV     DPH,A
   \   000045   E0           MOVX    A,@DPTR
   \   000046   64FE         XRL     A,#0xfe
   \   000048   7003         JNZ     ??ZDSecMgrEntryNew_3
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_3:
   \   00004D   7026         JNZ     ??ZDSecMgrEntryNew_4
    890                {
    891                  // return successful result
    892                  *entry = &ZDSecMgrEntries[index];
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   E5..         MOV     A,?V0 + 0
   \   000055   F0           MOVX    @DPTR,A
   \   000056   A3           INC     DPTR
   \   000057   E5..         MOV     A,?V0 + 1
   \   000059   F0           MOVX    @DPTR,A
    893                  status = ZSuccess;
   \   00005A   7900         MOV     R1,#0x0
    894          
    895                  // Set the authentication option to default
    896                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00005C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   2C           ADD     A,R4
   \   000061   FC           MOV     R4,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   3D           ADDC    A,R5
   \   000065   FD           MOV     R5,A
   \   000066   EC           MOV     A,R4
   \   000067   241C         ADD     A,#0x1c
   \   000069   F582         MOV     DPL,A
   \   00006B   ED           MOV     A,R5
   \   00006C   3400         ADDC    A,#0x0
   \   00006E   F583         MOV     DPH,A
   \   000070   E4           CLR     A
   \   000071   F0           MOVX    @DPTR,A
    897          
    898                  // break from loop
    899                  index = ZDSECMGR_ENTRY_MAX;
   \   000072   7E03         MOV     R6,#0x3
   \   000074   FF           MOV     R7,A
    900                }
    901              }
   \                     ??ZDSecMgrEntryNew_4:
   \   000075   EE           MOV     A,R6
   \   000076   2401         ADD     A,#0x1
   \   000078   0E           INC     R6
   \   000079   EF           MOV     A,R7
   \   00007A   3400         ADDC    A,#0x0
   \   00007C   FF           MOV     R7,A
   \                     ??ZDSecMgrEntryNew_1:
   \   00007D   C3           CLR     C
   \   00007E   EE           MOV     A,R6
   \   00007F   9403         SUBB    A,#0x3
   \   000081   EF           MOV     A,R7
   \   000082   9400         SUBB    A,#0x0
   \   000084   409B         JC      ??ZDSecMgrEntryNew_2
    902            }
    903          
    904            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   000086   7F02         MOV     R7,#0x2
   \   000088   02....       LJMP    ?BANKED_LEAVE_XDATA
    905          }
    906          
    907          /******************************************************************************
    908           * @fn          ZDSecMgrCtrlInit
    909           *
    910           * @brief       Initialize control sub module
    911           *
    912           * @param       none
    913           *
    914           * @return      none
    915           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    916          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    917          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    918            uint16 size;
    919            uint16 index;
    920          
    921            // allocate entry data
    922            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    923          
    924            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   EA           MOV     A,R2
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   EB           MOV     A,R3
   \   000012   F0           MOVX    @DPTR,A
    925          
    926            // initialize data
    927            if ( ZDSecMgrCtrlData != NULL )
   \   000013   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   49           ORL     A,R1
   \   00001D   603E         JZ      ??ZDSecMgrCtrlInit_0
    928            {
    929              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001F   7800         MOV     R0,#0x0
   \   000021   7900         MOV     R1,#0x0
   \   000023   802F         SJMP    ??ZDSecMgrCtrlInit_1
    930              {
    931                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_2:
   \   000025   E8           MOV     A,R0
   \   000026   FA           MOV     R2,A
   \   000027   E9           MOV     A,R1
   \   000028   FB           MOV     R3,A
   \   000029   EA           MOV     A,R2
   \   00002A   75F007       MOV     B,#0x7
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   ACF0         MOV     R4,B
   \   000031   75F007       MOV     B,#0x7
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   2C           ADD     A,R4
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   8C82         MOV     DPL,R4
   \   000043   F583         MOV     DPH,A
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
    932              }
   \   00004C   E8           MOV     A,R0
   \   00004D   2401         ADD     A,#0x1
   \   00004F   08           INC     R0
   \   000050   E9           MOV     A,R1
   \   000051   3400         ADDC    A,#0x0
   \   000053   F9           MOV     R1,A
   \                     ??ZDSecMgrCtrlInit_1:
   \   000054   C3           CLR     C
   \   000055   E8           MOV     A,R0
   \   000056   9403         SUBB    A,#0x3
   \   000058   E9           MOV     A,R1
   \   000059   9400         SUBB    A,#0x0
   \   00005B   40C8         JC      ??ZDSecMgrCtrlInit_2
    933            }
    934          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   00005D   D083         POP     DPH
   \   00005F   D082         POP     DPL
   \   000061   02....       LJMP    ?BRET
    935          
    936          /******************************************************************************
    937           * @fn          ZDSecMgrCtrlRelease
    938           *
    939           * @brief       Release control data.
    940           *
    941           * @param       ctrl - [in] valid control data
    942           *
    943           * @return      none
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    946          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    947            // should always be enough entry control data
    948            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
    949          }
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   02....       LJMP    ?BRET
    950          
    951          /******************************************************************************
    952           * @fn          ZDSecMgrCtrlLookup
    953           *
    954           * @brief       Lookup control data.
    955           *
    956           * @param       entry - [in] valid entry data
    957           * @param       ctrl  - [out] control data - NULL if not found
    958           *
    959           * @return      none
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    962          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    963            uint16 index;
    964          
    965          
    966            // initialize search results
    967            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    968          
    969            // verify data is available
    970            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   49           ORL     A,R1
   \   00001B   6068         JZ      ??ZDSecMgrCtrlLookup_0
    971            {
    972              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001D   7800         MOV     R0,#0x0
   \   00001F   7900         MOV     R1,#0x0
   \   000021   8059         SJMP    ??ZDSecMgrCtrlLookup_1
    973              {
    974                // make sure control data is in use
    975                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000023   E8           MOV     A,R0
   \   000024   FA           MOV     R2,A
   \   000025   E9           MOV     A,R1
   \   000026   FB           MOV     R3,A
   \   000027   EA           MOV     A,R2
   \   000028   75F007       MOV     B,#0x7
   \   00002B   A4           MUL     AB
   \   00002C   FA           MOV     R2,A
   \   00002D   85F0..       MOV     ?V0 + 0,B
   \   000030   75F007       MOV     B,#0x7
   \   000033   EB           MOV     A,R3
   \   000034   A4           MUL     AB
   \   000035   25..         ADD     A,?V0 + 0
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   2A           ADD     A,R2
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3B           ADDC    A,R3
   \   000041   FB           MOV     R3,A
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   6026         JZ      ??ZDSecMgrCtrlLookup_3
    976                {
    977                  // check for entry match
    978                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5..         MOV     ?V0 + 0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F5..         MOV     ?V0 + 1,A
   \   000059   EE           MOV     A,R6
   \   00005A   65..         XRL     A,?V0 + 0
   \   00005C   7003         JNZ     ??ZDSecMgrCtrlLookup_4
   \   00005E   EF           MOV     A,R7
   \   00005F   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   000061   7011         JNZ     ??ZDSecMgrCtrlLookup_3
    979                  {
    980                    // return this control data
    981                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000063   EA           MOV     A,R2
   \   000064   F8           MOV     R0,A
   \   000065   EB           MOV     A,R3
   \   000066   F9           MOV     R1,A
   \   000067   8C82         MOV     DPL,R4
   \   000069   8D83         MOV     DPH,R5
   \   00006B   E8           MOV     A,R0
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   E9           MOV     A,R1
   \   00006F   F0           MOVX    @DPTR,A
    982          
    983                    // break from loop
    984                    index = ZDSECMGR_CTRL_MAX;
   \   000070   7803         MOV     R0,#0x3
   \   000072   7900         MOV     R1,#0x0
    985                  }
    986                }
    987              }
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000074   E8           MOV     A,R0
   \   000075   2401         ADD     A,#0x1
   \   000077   08           INC     R0
   \   000078   E9           MOV     A,R1
   \   000079   3400         ADDC    A,#0x0
   \   00007B   F9           MOV     R1,A
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00007C   C3           CLR     C
   \   00007D   E8           MOV     A,R0
   \   00007E   9403         SUBB    A,#0x3
   \   000080   E9           MOV     A,R1
   \   000081   9400         SUBB    A,#0x0
   \   000083   409E         JC      ??ZDSecMgrCtrlLookup_2
    988            }
    989          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000085   7F02         MOV     R7,#0x2
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
    990          
    991          /******************************************************************************
    992           * @fn          ZDSecMgrCtrlSet
    993           *
    994           * @brief       Set control data.
    995           *
    996           * @param       device - [in] valid device data
    997           * @param       entry  - [in] valid entry data
    998           * @param       ctrl   - [in] valid control data
    999           *
   1000           * @return      none
   1001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1002          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1003                                ZDSecMgrEntry_t*  entry,
   1004                                ZDSecMgrCtrl_t*   ctrl )
   1005          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   1006            // set control date
   1007            ctrl->parentAddr = device->parentAddr;
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   1008            ctrl->secure     = device->secure;
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   F0           MOVX    @DPTR,A
   1009            ctrl->entry      = entry;
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
   1010            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   7401         MOV     A,#0x1
   \   00004F   F0           MOVX    @DPTR,A
   1011            ctrl->cntr       = 0;
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E4           CLR     A
   \   00005B   F0           MOVX    @DPTR,A
   1012          
   1013            // set device pointer
   1014            device->ctrl = ctrl;
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   E8           MOV     A,R0
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E9           MOV     A,R1
   \   00006C   F0           MOVX    @DPTR,A
   1015          }
   \   00006D   7F01         MOV     R7,#0x1
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1016          
   1017          /******************************************************************************
   1018           * @fn          ZDSecMgrCtrlAdd
   1019           *
   1020           * @brief       Add control data.
   1021           *
   1022           * @param       device - [in] valid device data
   1023           * @param       entry  - [in] valid entry data
   1024           *
   1025           * @return      ZStatus_t
   1026           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1027          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1028          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   1029            ZStatus_t status;
   1030            uint16    index;
   1031          
   1032          
   1033            // initialize results
   1034            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
   1035          
   1036            // verify data is available
   1037            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FA           MOV     R2,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FB           MOV     R3,A
   \   000017   EA           MOV     A,R2
   \   000018   4B           ORL     A,R3
   \   000019   605E         JZ      ??ZDSecMgrCtrlAdd_0
   1038            {
   1039              // look for an empty slot
   1040              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   804F         SJMP    ??ZDSecMgrCtrlAdd_1
   1041              {
   1042                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   EC           MOV     A,R4
   \   000026   75F007       MOV     B,#0x7
   \   000029   A4           MUL     AB
   \   00002A   FC           MOV     R4,A
   \   00002B   A8F0         MOV     R0,B
   \   00002D   75F007       MOV     B,#0x7
   \   000030   ED           MOV     A,R5
   \   000031   A4           MUL     AB
   \   000032   28           ADD     A,R0
   \   000033   FD           MOV     R5,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   E0           MOVX    A,@DPTR
   \   000038   2C           ADD     A,R4
   \   000039   F5..         MOV     ?V0 + 2,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   3D           ADDC    A,R5
   \   00003E   F5..         MOV     ?V0 + 3,A
   \   000040   85..82       MOV     DPL,?V0 + 2
   \   000043   F583         MOV     DPH,A
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   701B         JNZ     ??ZDSecMgrCtrlAdd_3
   1043                {
   1044                  // return successful results
   1045                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   00004D                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00004D   78..         MOV     R0,#?V0 + 2
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   AC..         MOV     R4,?V0 + 0
   \   000054   AD..         MOV     R5,?V0 + 1
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   1046          
   1047                  status = ZSuccess;
   \   000062   7900         MOV     R1,#0x0
   1048          
   1049                  // break from loop
   1050                  index = ZDSECMGR_CTRL_MAX;
   \   000064   7A03         MOV     R2,#0x3
   \   000066   7B00         MOV     R3,#0x0
   1051                }
   1052              }
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000068   EA           MOV     A,R2
   \   000069   2401         ADD     A,#0x1
   \   00006B   0A           INC     R2
   \   00006C   EB           MOV     A,R3
   \   00006D   3400         ADDC    A,#0x0
   \   00006F   FB           MOV     R3,A
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000070   C3           CLR     C
   \   000071   EA           MOV     A,R2
   \   000072   9403         SUBB    A,#0x3
   \   000074   EB           MOV     A,R3
   \   000075   9400         SUBB    A,#0x0
   \   000077   40A8         JC      ??ZDSecMgrCtrlAdd_2
   1053            }
   1054          
   1055            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000079   7F04         MOV     R7,#0x4
   \   00007B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1056          }
   1057          
   1058          /******************************************************************************
   1059           * @fn          ZDSecMgrCtrlTerm
   1060           *
   1061           * @brief       Terminate device control.
   1062           *
   1063           * @param       entry - [in] valid entry data
   1064           *
   1065           * @return      none
   1066           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1067          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1068          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1069            ZDSecMgrCtrl_t* ctrl;
   1070          
   1071            // remove device from control data
   1072            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1073          
   1074            if ( ctrl != NULL )
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   600E         JZ      ??ZDSecMgrCtrlTerm_0
   1075            {
   1076              ZDSecMgrCtrlRelease ( ctrl );
   \   000025                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   FA           MOV     R2,A
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   FB           MOV     R3,A
   \   000030   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1077            }
   1078          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   D083         POP     DPH
   \   00003A   D082         POP     DPL
   \   00003C   02....       LJMP    ?BRET
   1079          
   1080          /******************************************************************************
   1081           * @fn          ZDSecMgrCtrlReset
   1082           *
   1083           * @brief       Reset control data.
   1084           *
   1085           * @param       device - [in] valid device data
   1086           * @param       entry  - [in] valid entry data
   1087           *
   1088           * @return      ZStatus_t
   1089           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1090          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1091          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1092            ZStatus_t       status;
   1093            ZDSecMgrCtrl_t* ctrl;
   1094          
   1095          
   1096            // initialize results
   1097            status = ZNwkUnknownDevice;
   1098          
   1099            // look for a match for the entry
   1100            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1101          
   1102            if ( ctrl != NULL )
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F9           MOV     R1,A
   \   00002E   E8           MOV     A,R0
   \   00002F   49           ORL     A,R1
   \   000030   601D         JZ      ??ZDSecMgrCtrlReset_0
   1103            {
   1104              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003B   EE           MOV     A,R6
   \   00003C   FC           MOV     R4,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FD           MOV     R5,A
   \   00003F   AA..         MOV     R2,?V0 + 0
   \   000041   AB..         MOV     R3,?V0 + 1
   \   000043   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000046   7402         MOV     A,#0x2
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   1105          
   1106              status = ZSuccess;
   \   00004B   7900         MOV     R1,#0x0
   \   00004D   800B         SJMP    ??ZDSecMgrCtrlReset_1
   1107            }
   1108            else
   1109            {
   1110              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00004F                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00004F   EE           MOV     A,R6
   \   000050   FC           MOV     R4,A
   \   000051   EF           MOV     A,R7
   \   000052   FD           MOV     R5,A
   \   000053   AA..         MOV     R2,?V0 + 0
   \   000055   AB..         MOV     R3,?V0 + 1
   \   000057   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   1111            }
   1112          
   1113            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00005A   7402         MOV     A,#0x2
   \   00005C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005F   7F02         MOV     R7,#0x2
   \   000061   02....       LJMP    ?BANKED_LEAVE_XDATA
   1114          }
   1115          
   1116          /******************************************************************************
   1117           * @fn          ZDSecMgrMasterKeyLoad
   1118           *
   1119           * @brief       Load the MASTER key for device with specified EXT
   1120           *              address.
   1121           *
   1122           * @param       extAddr - [in] EXT address of device
   1123           * @param       key     - [in] MASTER key shared with device
   1124           *
   1125           * @return      ZStatus_t
   1126           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1127          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1128          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1129            ZStatus_t status;
   1130            uint8*    loaded;
   1131            uint16    ami;
   1132          
   1133          
   1134            // set status based on policy
   1135            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 3,A
   1136          
   1137            if ( status == ZSuccess )
   \   00001E   7053         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1138            {
   1139              // get the address index
   1140              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FB           MOV     R3,A
   \   000034   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000037   E9           MOV     A,R1
   \   000038   7024         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1141              {
   1142                // overwrite old key
   1143                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   00003A                ; Setup parameters for call to function osal_memcpy
   \   00003A   8E..         MOV     ?V0 + 0,R6
   \   00003C   8F..         MOV     ?V0 + 1,R7
   \   00003E   75..00       MOV     ?V0 + 2,#0x0
   \   000041   78..         MOV     R0,#?V0 + 0
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000046   7C10         MOV     R4,#0x10
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   7405         MOV     A,#0x5
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FA           MOV     R2,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FB           MOV     R3,A
   \   000054   12....       LCALL   ??osal_memcpy?relay
   \   000057   7403         MOV     A,#0x3
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   8015         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1144              }
   1145              else
   1146              {
   1147                // store new key -- NULL will zero key
   1148                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00005E                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00005E   EE           MOV     A,R6
   \   00005F   FC           MOV     R4,A
   \   000060   EF           MOV     A,R7
   \   000061   FD           MOV     R5,A
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FA           MOV     R2,A
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   000070   E9           MOV     A,R1
   \   000071   F5..         MOV     ?V0 + 3,A
   1149              }
   1150            }
   1151          
   1152            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000073   A9..         MOV     R1,?V0 + 3
   \   000075   7404         MOV     A,#0x4
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007A   7F04         MOV     R7,#0x4
   \   00007C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1153          }
   1154          
   1155          /******************************************************************************
   1156           * @fn          ZDSecMgrAppKeyGet
   1157           *
   1158           * @brief       get an APP key - option APP(MASTER or LINK) key
   1159           *
   1160           * @param       initNwkAddr - [in] NWK address of initiator device
   1161           * @param       initExtAddr - [in] EXT address of initiator device
   1162           * @param       partNwkAddr - [in] NWK address of partner device
   1163           * @param       partExtAddr - [in] EXT address of partner device
   1164           * @param       key         - [out] APP(MASTER or LINK) key
   1165           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1166           *
   1167           * @return      ZStatus_t
   1168           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1169          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1170                                                           // to KEY_TYPE_APP_LINK since
   1171                                                           // only specific requirement
   1172                                                           // right now comes from SE profile
   1173          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1174          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1175                                       uint8*  initExtAddr,
   1176                                       uint16  partNwkAddr,
   1177                                       uint8*  partExtAddr,
   1178                                       uint8** key,
   1179                                       uint8*  keyType )
   1180          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E8           MOV     A,R0
   \   000010   FA           MOV     R2,A
   \   000011   E9           MOV     A,R1
   \   000012   FB           MOV     R3,A
   \   000013   740F         MOV     A,#0xf
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   E8           MOV     A,R0
   \   00001E   FE           MOV     R6,A
   \   00001F   E9           MOV     A,R1
   \   000020   FF           MOV     R7,A
   1181            // Intentionally unreferenced parameters
   1182            (void)initNwkAddr;
   1183            (void)initExtAddr;
   1184            (void)partNwkAddr;
   1185            (void)partExtAddr;
   1186            
   1187            //---------------------------------------------------------------------------
   1188            // note:
   1189            // should use a robust mechanism to generate keys, for example
   1190            // combine EXT addresses and call a hash function
   1191            //---------------------------------------------------------------------------
   1192            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000021                ; Setup parameters for call to function SSP_GetTrueRand
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FA           MOV     R2,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FB           MOV     R3,A
   \   00002A   7910         MOV     R1,#0x10
   \   00002C   12....       LCALL   ??SSP_GetTrueRand?relay
   1193          
   1194            *keyType = ZDSecMgrAppKeyType;
   \   00002F   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000032   E0           MOVX    A,@DPTR
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   F0           MOVX    @DPTR,A
   1195          
   1196            return ZSuccess;
   \   000038   7900         MOV     R1,#0x0
   \   00003A   7F01         MOV     R7,#0x1
   \   00003C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1197          }
   1198          
   1199          /******************************************************************************
   1200           * @fn          ZDSecMgrAppKeyReq
   1201           *
   1202           * @brief       Process request for APP key between two devices.
   1203           *
   1204           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1205           *
   1206           * @return      none
   1207           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1208          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1209          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1210            APSME_TransportKeyReq_t req;
   1211            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1212            uint16                  partNwkAddr;
   1213            uint8                   key[SEC_KEY_LEN];
   1214          
   1215          
   1216            // validate initiator and partner
   1217            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1218                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EE           MOV     A,R6
   \   00000F   2405         ADD     A,#0x5
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   AA..         MOV     R2,?V0 + 0
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000028   E9           MOV     A,R1
   \   000029   6401         XRL     A,#0x1
   \   00002B   6003         JZ      $+5
   \   00002D   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000030   EE           MOV     A,R6
   \   000031   2402         ADD     A,#0x2
   \   000033   EF           MOV     A,R7
   \   000034   3400         ADDC    A,#0x0
   \   000036   0E           INC     R6
   \   000037   0E           INC     R6
   \   000038   FF           MOV     R7,A
   \   000039                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000039   740F         MOV     A,#0xf
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   AC82         MOV     R4,DPL
   \   000040   AD83         MOV     R5,DPH
   \   000042   8E82         MOV     DPL,R6
   \   000044   8F83         MOV     DPH,R7
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FA           MOV     R2,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FB           MOV     R3,A
   \   00004B   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00004E   E9           MOV     A,R1
   \   00004F   6401         XRL     A,#0x1
   \   000051   6003         JZ      $+5
   \   000053   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1219            {
   1220              // point the key to some memory
   1221              req.key = key;
   \   000056   7417         MOV     A,#0x17
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   A882         MOV     R0,DPL
   \   00005D   A983         MOV     R1,DPH
   \   00005F   7406         MOV     A,#0x6
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   E8           MOV     A,R0
   \   000065   F0           MOVX    @DPTR,A
   \   000066   A3           INC     DPTR
   \   000067   E9           MOV     A,R1
   \   000068   F0           MOVX    @DPTR,A
   1222          
   1223              // get an APP key - option APP (MASTER or LINK) key
   1224              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1225                                      initExtAddr,
   1226                                      partNwkAddr,
   1227                                      ind->partExtAddr,
   1228                                      &req.key,
   1229                                      &req.keyType ) == ZSuccess )
   \   000069                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   000069   7404         MOV     A,#0x4
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   8582..       MOV     ?V0 + 2,DPL
   \   000071   8583..       MOV     ?V0 + 3,DPH
   \   000074   78..         MOV     R0,#?V0 + 2
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000079   7408         MOV     A,#0x8
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   8582..       MOV     ?V0 + 2,DPL
   \   000081   8583..       MOV     ?V0 + 3,DPH
   \   000084   78..         MOV     R0,#?V0 + 2
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008E   7406         MOV     A,#0x6
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000096   7417         MOV     A,#0x17
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   AC82         MOV     R4,DPL
   \   00009D   AD83         MOV     R5,DPH
   \   00009F   8E82         MOV     DPL,R6
   \   0000A1   8F83         MOV     DPH,R7
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   FA           MOV     R2,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   FB           MOV     R3,A
   \   0000A8   12....       LCALL   ??ZDSecMgrAppKeyGet?relay
   \   0000AB   7408         MOV     A,#0x8
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   6003         JZ      $+5
   \   0000B3   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1230              {
   1231                // always secure
   1232                req.nwkSecure = TRUE;
   \   0000B6   740C         MOV     A,#0xc
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   7401         MOV     A,#0x1
   \   0000BD   F0           MOVX    @DPTR,A
   1233                req.apsSecure = TRUE;
   \   0000BE   740B         MOV     A,#0xb
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   7401         MOV     A,#0x1
   \   0000C5   F0           MOVX    @DPTR,A
   1234                req.tunnel    = NULL;
   \   0000C6   740D         MOV     A,#0xd
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   E4           CLR     A
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   F0           MOVX    @DPTR,A
   1235          
   1236                // send key to initiator device
   1237                req.dstAddr   = ind->srcAddr;
   \   0000CF   8E82         MOV     DPL,R6
   \   0000D1   8F83         MOV     DPH,R7
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   F8           MOV     R0,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   F9           MOV     R1,A
   \   0000D8   7402         MOV     A,#0x2
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   E8           MOV     A,R0
   \   0000DE   F0           MOVX    @DPTR,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E9           MOV     A,R1
   \   0000E1   F0           MOVX    @DPTR,A
   1238                req.extAddr   = ind->partExtAddr;
   \   0000E2   7408         MOV     A,#0x8
   \   0000E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E7   E5..         MOV     A,?V0 + 0
   \   0000E9   F0           MOVX    @DPTR,A
   \   0000EA   A3           INC     DPTR
   \   0000EB   E5..         MOV     A,?V0 + 1
   \   0000ED   F0           MOVX    @DPTR,A
   1239                req.initiator = TRUE;
   \   0000EE   740A         MOV     A,#0xa
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   7401         MOV     A,#0x1
   \   0000F5   F0           MOVX    @DPTR,A
   1240                APSME_TransportKeyReq( &req );
   \   0000F6                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F6   04           INC     A
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   AA82         MOV     R2,DPL
   \   0000FC   AB83         MOV     R3,DPH
   \   0000FE   12....       LCALL   ??APSME_TransportKeyReq?relay
   1241          
   1242                // send key to partner device
   1243                req.dstAddr   = partNwkAddr;
   \   000101   85..82       MOV     DPL,?XSP + 0
   \   000104   85..83       MOV     DPH,?XSP + 1
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F8           MOV     R0,A
   \   000109   A3           INC     DPTR
   \   00010A   E0           MOVX    A,@DPTR
   \   00010B   F9           MOV     R1,A
   \   00010C   7402         MOV     A,#0x2
   \   00010E   12....       LCALL   ?XSTACK_DISP0_8
   \   000111   E8           MOV     A,R0
   \   000112   F0           MOVX    @DPTR,A
   \   000113   A3           INC     DPTR
   \   000114   E9           MOV     A,R1
   \   000115   F0           MOVX    @DPTR,A
   1244                req.extAddr   = initExtAddr;
   \   000116   740F         MOV     A,#0xf
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   A882         MOV     R0,DPL
   \   00011D   A983         MOV     R1,DPH
   \   00011F   7408         MOV     A,#0x8
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   E8           MOV     A,R0
   \   000125   F0           MOVX    @DPTR,A
   \   000126   A3           INC     DPTR
   \   000127   E9           MOV     A,R1
   \   000128   F0           MOVX    @DPTR,A
   1245                req.initiator = FALSE;
   \   000129   740A         MOV     A,#0xa
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   E4           CLR     A
   \   00012F   F0           MOVX    @DPTR,A
   1246          
   1247                APSME_TransportKeyReq( &req );
   \   000130                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000130   7402         MOV     A,#0x2
   \   000132   12....       LCALL   ?XSTACK_DISP0_8
   \   000135   AA82         MOV     R2,DPL
   \   000137   AB83         MOV     R3,DPH
   \   000139   12....       LCALL   ??APSME_TransportKeyReq?relay
   1248              }
   1249            }
   1250          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   00013C   7427         MOV     A,#0x27
   \   00013E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000141   7F04         MOV     R7,#0x4
   \   000143   02....       LJMP    ?BANKED_LEAVE_XDATA
   1251          
   1252          /******************************************************************************
   1253           * @fn          ZDSecMgrEstablishKey
   1254           *
   1255           * @brief       Start SKKE with device joining network.
   1256           *
   1257           * @param       device - [in] ZDSecMgrDevice_t, device info
   1258           *
   1259           * @return      ZStatus_t
   1260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1261          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1262          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1263            ZStatus_t               status;
   1264            APSME_EstablishKeyReq_t req;
   1265          
   1266          
   1267            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   1268            req.method      = APSME_SKKE_METHOD;
   \   000023   7404         MOV     A,#0x4
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   1269          
   1270            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00002A   EE           MOV     A,R6
   \   00002B   2404         ADD     A,#0x4
   \   00002D   F8           MOV     R0,A
   \   00002E   EF           MOV     A,R7
   \   00002F   3400         ADDC    A,#0x0
   \   000031   F9           MOV     R1,A
   \   000032   88..         MOV     ?V0 + 0,R0
   \   000034   89..         MOV     ?V0 + 1,R1
   \   000036   8882         MOV     DPL,R0
   \   000038   F583         MOV     DPH,A
   \   00003A   C082         PUSH    DPL
   \   00003C   C083         PUSH    DPH
   \   00003E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00003E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000041   8A..         MOV     ?V0 + 2,R2
   \   000043   8B..         MOV     ?V0 + 3,R3
   \   000045   D083         POP     DPH
   \   000047   D082         POP     DPL
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   65..         XRL     A,?V0 + 2
   \   00004C   7004         JNZ     ??ZDSecMgrEstablishKey_0
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrEstablishKey_0:
   \   000052   7023         JNZ     ??ZDSecMgrEstablishKey_1
   1271            {
   1272              req.dstAddr   = device->nwkAddr;
   \   000054   8E82         MOV     DPL,R6
   \   000056   8F83         MOV     DPH,R7
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F8           MOV     R0,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E8           MOV     A,R0
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
   1273              //devtag.0604.todo - remove obsolete
   1274              req.apsSecure = FALSE;
   \   000068   7405         MOV     A,#0x5
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E4           CLR     A
   \   00006E   F0           MOVX    @DPTR,A
   1275              req.nwkSecure = FALSE;
   \   00006F   7406         MOV     A,#0x6
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E4           CLR     A
   \   000075   8025         SJMP    ??ZDSecMgrEstablishKey_2
   1276            }
   1277            else
   1278            {
   1279              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000077   85..82       MOV     DPL,?V0 + 0
   \   00007A   85..83       MOV     DPH,?V0 + 1
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   F8           MOV     R0,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   F9           MOV     R1,A
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   E8           MOV     A,R0
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   E9           MOV     A,R1
   \   00008C   F0           MOVX    @DPTR,A
   1280              //devtag.0604.todo - remove obsolete
   1281              req.apsSecure = TRUE;
   \   00008D   7405         MOV     A,#0x5
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   7401         MOV     A,#0x1
   \   000094   F0           MOVX    @DPTR,A
   1282              req.nwkSecure = TRUE;
   \   000095   7406         MOV     A,#0x6
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   7401         MOV     A,#0x1
   \                     ??ZDSecMgrEstablishKey_2:
   \   00009C   F0           MOVX    @DPTR,A
   1283            }
   1284          
   1285            status = APSME_EstablishKeyReq( &req );
   1286          
   1287            return status;
   \   00009D                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   00009D   85..82       MOV     DPL,?XSP + 0
   \   0000A0   85..83       MOV     DPH,?XSP + 1
   \   0000A3   AA82         MOV     R2,DPL
   \   0000A5   AB83         MOV     R3,DPH
   \   0000A7   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   0000AA   7407         MOV     A,#0x7
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AF   7F04         MOV     R7,#0x4
   \   0000B1   02....       LJMP    ?BANKED_LEAVE_XDATA
   1288          }
   1289          
   1290          /******************************************************************************
   1291           * @fn          ZDSecMgrSendMasterKey
   1292           *
   1293           * @brief       Send MASTER key to device joining network.
   1294           *
   1295           * @param       device - [in] ZDSecMgrDevice_t, device info
   1296           *
   1297           * @return      ZStatus_t
   1298           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1299          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1300          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1301            ZStatus_t               status;
   1302            APSME_TransportKeyReq_t req;
   1303          
   1304          
   1305            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   F0           MOVX    @DPTR,A
   1306            req.extAddr = device->extAddr;
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F9           MOV     R1,A
   \   000020   7406         MOV     A,#0x6
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E8           MOV     A,R0
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   E9           MOV     A,R1
   \   000029   F0           MOVX    @DPTR,A
   1307            req.tunnel  = NULL;
   \   00002A   740B         MOV     A,#0xb
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E4           CLR     A
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   F0           MOVX    @DPTR,A
   1308          
   1309            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000033                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   8E82         MOV     DPL,R6
   \   00003E   8F83         MOV     DPH,R7
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F8           MOV     R0,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F583         MOV     DPH,A
   \   00004E   8882         MOV     DPL,R0
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F583         MOV     DPH,A
   \   000056   8882         MOV     DPL,R0
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FA           MOV     R2,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FB           MOV     R3,A
   \   00005D   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   1310          
   1311            //check if using secure hop to to parent
   1312            if ( device->parentAddr != NLME_GetShortAddr() )
   \   000060   EE           MOV     A,R6
   \   000061   2404         ADD     A,#0x4
   \   000063   F8           MOV     R0,A
   \   000064   EF           MOV     A,R7
   \   000065   3400         ADDC    A,#0x0
   \   000067   F9           MOV     R1,A
   \   000068   88..         MOV     ?V0 + 0,R0
   \   00006A   89..         MOV     ?V0 + 1,R1
   \   00006C   8882         MOV     DPL,R0
   \   00006E   F583         MOV     DPH,A
   \   000070   C082         PUSH    DPL
   \   000072   C083         PUSH    DPH
   \   000074                ; Setup parameters for call to function NLME_GetShortAddr
   \   000074   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000077   8A..         MOV     ?V0 + 2,R2
   \   000079   8B..         MOV     ?V0 + 3,R3
   \   00007B   D083         POP     DPH
   \   00007D   D082         POP     DPL
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   65..         XRL     A,?V0 + 2
   \   000082   7004         JNZ     ??ZDSecMgrSendMasterKey_0
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000088   6027         JZ      ??ZDSecMgrSendMasterKey_1
   1313            {
   1314              //send to parent with security
   1315              req.dstAddr   = device->parentAddr;
   \   00008A   85..82       MOV     DPL,?V0 + 0
   \   00008D   85..83       MOV     DPH,?V0 + 1
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F8           MOV     R0,A
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F9           MOV     R1,A
   \   000095   85..82       MOV     DPL,?XSP + 0
   \   000098   85..83       MOV     DPH,?XSP + 1
   \   00009B   E8           MOV     A,R0
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   A3           INC     DPTR
   \   00009E   E9           MOV     A,R1
   \   00009F   F0           MOVX    @DPTR,A
   1316              req.nwkSecure = TRUE;
   \   0000A0   740A         MOV     A,#0xa
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   7401         MOV     A,#0x1
   \   0000A7   F0           MOVX    @DPTR,A
   1317              req.apsSecure = TRUE;
   \   0000A8   7409         MOV     A,#0x9
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   7401         MOV     A,#0x1
   \   0000AF   8021         SJMP    ??ZDSecMgrSendMasterKey_2
   1318            }
   1319            else
   1320            {
   1321              //direct with no security
   1322              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   0000B1   8E82         MOV     DPL,R6
   \   0000B3   8F83         MOV     DPH,R7
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   85..82       MOV     DPL,?XSP + 0
   \   0000BD   85..83       MOV     DPH,?XSP + 1
   \   0000C0   E8           MOV     A,R0
   \   0000C1   F0           MOVX    @DPTR,A
   \   0000C2   A3           INC     DPTR
   \   0000C3   E9           MOV     A,R1
   \   0000C4   F0           MOVX    @DPTR,A
   1323              req.nwkSecure = FALSE;
   \   0000C5   740A         MOV     A,#0xa
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   E4           CLR     A
   \   0000CB   F0           MOVX    @DPTR,A
   1324              req.apsSecure = FALSE;
   \   0000CC   7409         MOV     A,#0x9
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   E4           CLR     A
   \                     ??ZDSecMgrSendMasterKey_2:
   \   0000D2   F0           MOVX    @DPTR,A
   1325            }
   1326          
   1327            status = APSME_TransportKeyReq( &req );
   1328          
   1329            return status;
   \   0000D3                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000D3   85..82       MOV     DPL,?XSP + 0
   \   0000D6   85..83       MOV     DPH,?XSP + 1
   \   0000D9   AA82         MOV     R2,DPL
   \   0000DB   AB83         MOV     R3,DPH
   \   0000DD   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000E0   740D         MOV     A,#0xd
   \   0000E2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E5   7F04         MOV     R7,#0x4
   \   0000E7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1330          }
   1331          
   1332          /******************************************************************************
   1333           * @fn          ZDSecMgrSendNwkKey
   1334           *
   1335           * @brief       Send NWK key to device joining network.
   1336           *
   1337           * @param       device - [in] ZDSecMgrDevice_t, device info
   1338           *
   1339           * @return      ZStatus_t
   1340           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1341          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1342          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1343            ZStatus_t               status;
   1344            APSME_TransportKeyReq_t req;
   1345            APSDE_FrameTunnel_t     tunnel;
   1346          
   1347            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E8           MOV     A,R0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   E9           MOV     A,R1
   \   000021   F0           MOVX    @DPTR,A
   1348            req.extAddr   = device->extAddr;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   7406         MOV     A,#0x6
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E8           MOV     A,R0
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
   1349          
   1350            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1351              req.keyType   = KEY_TYPE_NWK_HIGH;
   1352            else
   1353              req.keyType   = KEY_TYPE_NWK;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   7401         MOV     A,#0x1
   \   00003E   F0           MOVX    @DPTR,A
   1354          
   1355            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1356                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1357            {
   1358              // set values
   1359              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1360              req.key       = _NIB.nwkActiveKey.key;
   1361              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1362              //key isn't used to secure the frame at the APS layer -- since the receiving
   1363              //device may not have a NWK key yet
   1364              req.apsSecure = TRUE;
   1365          
   1366              // check if using secure hop to to parent
   1367              if ( device->parentAddr == NLME_GetShortAddr() )
   1368              {
   1369                req.nwkSecure = FALSE;
   1370                req.tunnel    = NULL;
   1371              }
   1372              else
   1373              {
   1374                req.nwkSecure   = TRUE;
   1375                req.tunnel      = &tunnel;
   1376                req.tunnel->tna = device->parentAddr;
   1377                req.tunnel->dea = device->extAddr;
   1378              }
   1379            }
   1380            else
   1381            {
   1382              // default values
   1383              //devtag.0604.verify
   1384              req.nwkSecure = TRUE;
   \   00003F   740A         MOV     A,#0xa
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   7401         MOV     A,#0x1
   \   000046   F0           MOVX    @DPTR,A
   1385              req.apsSecure = FALSE;
   \   000047   7409         MOV     A,#0x9
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E4           CLR     A
   \   00004D   F0           MOVX    @DPTR,A
   1386              req.tunnel    = NULL;
   \   00004E   740B         MOV     A,#0xb
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   F0           MOVX    @DPTR,A
   1387          
   1388              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000057   EE           MOV     A,R6
   \   000058   2404         ADD     A,#0x4
   \   00005A   F8           MOV     R0,A
   \   00005B   EF           MOV     A,R7
   \   00005C   3400         ADDC    A,#0x0
   \   00005E   F9           MOV     R1,A
   \   00005F   88..         MOV     ?V0 + 0,R0
   \   000061   89..         MOV     ?V0 + 1,R1
   \   000063   8882         MOV     DPL,R0
   \   000065   F583         MOV     DPH,A
   \   000067   C082         PUSH    DPL
   \   000069   C083         PUSH    DPH
   \   00006B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00006B   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006E   8A..         MOV     ?V0 + 2,R2
   \   000070   8B..         MOV     ?V0 + 3,R3
   \   000072   D083         POP     DPH
   \   000074   D082         POP     DPL
   \   000076   E0           MOVX    A,@DPTR
   \   000077   65..         XRL     A,?V0 + 2
   \   000079   7004         JNZ     ??ZDSecMgrSendNwkKey_0
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00007F   6016         JZ      ??ZDSecMgrSendNwkKey_1
   1389              {
   1390                req.dstAddr = device->parentAddr;
   \   000081   85..82       MOV     DPL,?V0 + 0
   \   000084   85..83       MOV     DPH,?V0 + 1
   \   000087   E0           MOVX    A,@DPTR
   \   000088   F8           MOV     R0,A
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   F9           MOV     R1,A
   \   00008C   85..82       MOV     DPL,?XSP + 0
   \   00008F   85..83       MOV     DPH,?XSP + 1
   \   000092   E8           MOV     A,R0
   \   000093   F0           MOVX    @DPTR,A
   \   000094   A3           INC     DPTR
   \   000095   E9           MOV     A,R1
   \   000096   F0           MOVX    @DPTR,A
   1391              }
   1392          
   1393              // special cases
   1394              //devtag.0604.todo - modify to preconfig flag
   1395              if ( device->secure == FALSE )
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000097   8E82         MOV     DPL,R6
   \   000099   8F83         MOV     DPH,R7
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   703E         JNZ     ??ZDSecMgrSendNwkKey_2
   1396              {
   1397                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   0000A4   90....       MOV     DPTR,#_NIB + 62
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   C0E0         PUSH    A
   \   0000AA   7403         MOV     A,#0x3
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   D0E0         POP     A
   \   0000B1   F0           MOVX    @DPTR,A
   1398                req.key       = _NIB.nwkActiveKey.key;
   \   0000B2   7404         MOV     A,#0x4
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   74..         MOV     A,#(_NIB + 63) & 0xff
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   74..         MOV     A,#((_NIB + 63) >> 8) & 0xff
   \   0000BD   F0           MOVX    @DPTR,A
   1399          
   1400                // check if using secure hop to to parent
   1401                if ( device->parentAddr == NLME_GetShortAddr() )
   \   0000BE   85..82       MOV     DPL,?V0 + 0
   \   0000C1   85..83       MOV     DPH,?V0 + 1
   \   0000C4   C082         PUSH    DPL
   \   0000C6   C083         PUSH    DPH
   \   0000C8                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000C8   12....       LCALL   ??NLME_GetShortAddr?relay
   \   0000CB   8A..         MOV     ?V0 + 0,R2
   \   0000CD   8B..         MOV     ?V0 + 1,R3
   \   0000CF   D083         POP     DPH
   \   0000D1   D082         POP     DPL
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   65..         XRL     A,?V0 + 0
   \   0000D6   7004         JNZ     ??ZDSecMgrSendNwkKey_3
   \   0000D8   A3           INC     DPTR
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000DC   7014         JNZ     ??ZDSecMgrSendNwkKey_4
   1402                {
   1403                  req.nwkSecure = FALSE;
   \   0000DE   740A         MOV     A,#0xa
   \   0000E0   800B         SJMP    ??ZDSecMgrSendNwkKey_5
   1404                }
   1405              }
   1406              else
   1407              {
   1408                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000E2   7404         MOV     A,#0x4
   \   0000E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E7   E4           CLR     A
   \   0000E8   F0           MOVX    @DPTR,A
   \   0000E9   A3           INC     DPTR
   \   0000EA   F0           MOVX    @DPTR,A
   1409                req.keySeqNum = 0;
   \   0000EB   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   E4           CLR     A
   \   0000F1   F0           MOVX    @DPTR,A
   1410              }
   1411            }
   1412          
   1413            status = APSME_TransportKeyReq( &req );
   1414          
   1415            return status;
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000F2                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F2   85..82       MOV     DPL,?XSP + 0
   \   0000F5   85..83       MOV     DPH,?XSP + 1
   \   0000F8   AA82         MOV     R2,DPL
   \   0000FA   AB83         MOV     R3,DPH
   \   0000FC   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000FF   740D         MOV     A,#0xd
   \   000101   12....       LCALL   ?DEALLOC_XSTACK8
   \   000104   7F04         MOV     R7,#0x4
   \   000106   02....       LJMP    ?BANKED_LEAVE_XDATA
   1416          }
   1417          
   1418          /******************************************************************************
   1419           * @fn          ZDSecMgrDeviceEntryRemove
   1420           *
   1421           * @brief       Remove device entry.
   1422           *
   1423           * @param       entry - [in] valid entry
   1424           *
   1425           * @return      none
   1426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1427          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1428          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1429            // terminate device control
   1430            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1431            {
   1432              ZDSecMgrCtrlTerm( entry );
   1433            }
   1434          
   1435            // remove device from entry data
   1436            ZDSecMgrEntryFree( entry );
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000004   12....       LCALL   ??ZDSecMgrEntryFree?relay
   1437          
   1438            // remove EXT address
   1439            //ZDSecMgrExtAddrRelease( aiOld );
   1440          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   1441          
   1442          /******************************************************************************
   1443           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1444           *
   1445           * @brief       Remove device entry by its ext address.
   1446           *
   1447           * @param       pAddr - pointer to the extended address
   1448           *
   1449           * @return      ZStatus_t
   1450           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1451          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1452          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1453            ZDSecMgrEntry_t *pEntry;
   1454            uint8           retValue;
   1455            
   1456            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000017   E9           MOV     A,R1
   \   000018   FE           MOV     R6,A
   1457            
   1458            if( retValue == ZSuccess )
   \   000019   700E         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1459            {
   1460              ZDSecMgrDeviceEntryRemove( pEntry );
   \   00001B                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FA           MOV     R2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   FB           MOV     R3,A
   \   000026   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1461            }
   1462            
   1463            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000029   EE           MOV     A,R6
   \   00002A   F9           MOV     R1,A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000030   7F01         MOV     R7,#0x1
   \   000032   02....       LJMP    ?BANKED_LEAVE_XDATA
   1464          }
   1465          
   1466          /******************************************************************************
   1467           * @fn          ZDSecMgrDeviceEntryAdd
   1468           *
   1469           * @brief       Add entry.
   1470           *
   1471           * @param       device - [in] ZDSecMgrDevice_t, device info
   1472           * @param       ami    - [in] Address Manager index
   1473           *
   1474           * @return      ZStatus_t
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1477          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1478            AddrMgrEntry_t entry;
   1479          
   1480            // get the ami data
   1481            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
   1482            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   EA           MOV     A,R2
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   EB           MOV     A,R3
   \   000020   F0           MOVX    @DPTR,A
   1483          
   1484            AddrMgrEntryGet( &entry );
   \   000021                ; Setup parameters for call to function AddrMgrEntryGet
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AA82         MOV     R2,DPL
   \   000029   AB83         MOV     R3,DPH
   \   00002B   12....       LCALL   ??AddrMgrEntryGet?relay
   1485          
   1486            // check if NWK address is same
   1487            if ( entry.nwkAddr != nwkAddr )
   \   00002E   7401         MOV     A,#0x1
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6E           XRL     A,R6
   \   000035   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00003A   6017         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1488            {
   1489              // update NWK address
   1490              entry.nwkAddr = nwkAddr;
   \   00003C   7401         MOV     A,#0x1
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   EE           MOV     A,R6
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   EF           MOV     A,R7
   \   000045   F0           MOVX    @DPTR,A
   1491          
   1492              AddrMgrEntryUpdate( &entry );
   \   000046                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   AA82         MOV     R2,DPL
   \   00004E   AB83         MOV     R3,DPH
   \   000050   12....       LCALL   ??AddrMgrEntryUpdate?relay
   1493            }
   1494          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   000053   740D         MOV     A,#0xd
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
   \   000058   7F01         MOV     R7,#0x1
   \   00005A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1495          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1496          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1497          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1498            ZStatus_t        status;
   1499            ZDSecMgrEntry_t* entry;
   1500          
   1501          
   1502            // initialize as unknown until completion
   1503            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1504          
   1505            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   1506          
   1507            // make sure not already registered
   1508            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   000025                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   AC82         MOV     R4,DPL
   \   00002D   AD83         MOV     R5,DPH
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FA           MOV     R2,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   00003B   E9           MOV     A,R1
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   7047         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1509            {
   1510              // verify that address index is same
   1511              if ( entry->ami != ami )
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F8           MOV     R0,A
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F583         MOV     DPH,A
   \   00004A   8882         MOV     DPL,R0
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   6E           XRL     A,R6
   \   00004E   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000053   6044         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1512              {
   1513                // remove conflicting entry
   1514                ZDSecMgrDeviceEntryRemove( entry );
   \   000055                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000055   85..82       MOV     DPL,?XSP + 0
   \   000058   85..83       MOV     DPH,?XSP + 1
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1515          
   1516                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   000063                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000063   85..82       MOV     DPL,?XSP + 0
   \   000066   85..83       MOV     DPH,?XSP + 1
   \   000069   AC82         MOV     R4,DPL
   \   00006B   AD83         MOV     R5,DPH
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000074   E9           MOV     A,R1
   \   000075   7022         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1517                {
   1518                  // update NWK address
   1519                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000077                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000077   85..82       MOV     DPL,?V0 + 0
   \   00007A   85..83       MOV     DPH,?V0 + 1
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   FC           MOV     R4,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   FD           MOV     R5,A
   \   000082   EE           MOV     A,R6
   \   000083   FA           MOV     R2,A
   \   000084   EF           MOV     A,R7
   \   000085   FB           MOV     R3,A
   \   000086   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   000089   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1520                }
   1521              }
   1522            }
   1523            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00008B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00008B   AC82         MOV     R4,DPL
   \   00008D   AD83         MOV     R5,DPH
   \   00008F   EE           MOV     A,R6
   \   000090   FA           MOV     R2,A
   \   000091   EF           MOV     A,R7
   \   000092   FB           MOV     R3,A
   \   000093   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000096   E9           MOV     A,R1
   \   000097   60DE         JZ      ??ZDSecMgrDeviceEntryAdd_3
   1524            {
   1525              // update NWK address
   1526              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1527            }
   1528          
   1529            // check if a new entry needs to be created
   1530            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   F8           MOV     R0,A
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F9           MOV     R1,A
   \   0000A4   E8           MOV     A,R0
   \   0000A5   49           ORL     A,R1
   \   0000A6   7035         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1531            {
   1532              // get new entry
   1533              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   0000A8                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   0000A8   85..82       MOV     DPL,?XSP + 0
   \   0000AB   85..83       MOV     DPH,?XSP + 1
   \   0000AE   AA82         MOV     R2,DPL
   \   0000B0   AB83         MOV     R3,DPH
   \   0000B2   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   0000B5   E9           MOV     A,R1
   \   0000B6   7028         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1534              {
   1535                // reset entry lkd
   1536          
   1537                // finish setting up entry
   1538                entry->ami = ami;
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F583         MOV     DPH,A
   \   0000C4   8882         MOV     DPL,R0
   \   0000C6   EE           MOV     A,R6
   \   0000C7   F0           MOVX    @DPTR,A
   \   0000C8   A3           INC     DPTR
   \   0000C9   EF           MOV     A,R7
   \   0000CA   F0           MOVX    @DPTR,A
   1539          
   1540                // update NWK address
   1541                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000CB                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000CB   85..82       MOV     DPL,?V0 + 0
   \   0000CE   85..83       MOV     DPH,?V0 + 1
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   FC           MOV     R4,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   FD           MOV     R5,A
   \   0000D6   EE           MOV     A,R6
   \   0000D7   FA           MOV     R2,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   FB           MOV     R3,A
   \   0000DA   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   1542          
   1543                // enter new device into device control
   1544                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1545                {
   1546                  status = ZDSecMgrCtrlAdd( device, entry );
   1547                }
   1548                else
   1549                {
   1550                  status = ZSuccess;
   1551                }
   1552              }
   1553            }
   1554            else
   1555            {
   1556              // reset entry lkd
   1557          
   1558              // reset entry in entry control
   1559              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1560              {
   1561                status = ZDSecMgrCtrlReset( device, entry );
   1562              }
   1563              else
   1564              {
   1565                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   0000DD   75..00       MOV     ?V0 + 2,#0x0
   1566              }
   1567            }
   1568          
   1569            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   0000E0   A9..         MOV     R1,?V0 + 2
   \   0000E2   7402         MOV     A,#0x2
   \   0000E4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E7   7F03         MOV     R7,#0x3
   \   0000E9   02....       LJMP    ?BANKED_LEAVE_XDATA
   1570          }
   1571          
   1572          /******************************************************************************
   1573           * @fn          ZDSecMgrDeviceCtrlHandler
   1574           *
   1575           * @brief       Device control handler.
   1576           *
   1577           * @param       device - [in] ZDSecMgrDevice_t, device info
   1578           *
   1579           * @return      none
   1580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1581          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1582          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1583            uint8 state;
   1584            uint8 cntr;
   1585          
   1586          
   1587            state = device->ctrl->state;
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   F8           MOV     R0,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   FE           MOV     R6,A
   \   00000F   E9           MOV     A,R1
   \   000010   FF           MOV     R7,A
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F8           MOV     R0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F583         MOV     DPH,A
   \   00001B   8882         MOV     DPL,R0
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 0,A
   1588            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1589          
   1590            switch ( state )
   \   000025   24FE         ADD     A,#-0x2
   \   000027   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   000029   14           DEC     A
   \   00002A   6014         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   00002C   14           DEC     A
   \   00002D   6025         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   00002F   24FD         ADD     A,#-0x3
   \   000031   6018         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   000033   801C         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1591            {
   1592              case ZDSECMGR_CTRL_TK_MASTER:
   1593                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000035                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000035   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000038   E9           MOV     A,R1
   \   000039   7019         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1594                {
   1595                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   00003B   75..03       MOV     ?V0 + 0,#0x3
   1596                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00003E   8014         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1597                }
   1598                break;
   1599          
   1600              case ZDSECMGR_CTRL_SKKE_INIT:
   1601                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   000040                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000040   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   000043   E9           MOV     A,R1
   \   000044   700E         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1602                {
   1603                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000046   75..04       MOV     ?V0 + 0,#0x4
   \   000049   8009         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1604                }
   1605                break;
   1606          
   1607              case ZDSECMGR_CTRL_SKKE_WAIT:
   1608                // continue to wait for SKA control timeout
   1609                break;
   1610          
   1611              case ZDSECMGR_CTRL_TK_NWK:
   1612                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   00004B                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00004B   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00004E   E9           MOV     A,R1
   \   00004F   7003         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1613                {
   1614                  state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000051   75..00       MOV     ?V0 + 0,#0x0
   1615                }
   1616                break;
   1617          
   1618              default:
   1619                state = ZDSECMGR_CTRL_NONE;
   1620                break;
   1621            }
   1622          
   1623            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000054   E5..         MOV     A,?V0 + 0
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   6036         JZ      ??ZDSecMgrDeviceCtrlHandler_5
   1624            {
   1625              device->ctrl->state = state;
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F8           MOV     R0,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F583         MOV     DPH,A
   \   000062   8882         MOV     DPL,R0
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E5..         MOV     A,?V0 + 0
   \   00006B   F0           MOVX    @DPTR,A
   1626              device->ctrl->cntr  = cntr;
   \   00006C   8E82         MOV     DPL,R6
   \   00006E   8F83         MOV     DPH,R7
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F8           MOV     R0,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   F583         MOV     DPH,A
   \   000076   8882         MOV     DPL,R0
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   7401         MOV     A,#0x1
   \   000080   F0           MOVX    @DPTR,A
   1627          
   1628              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000081                ; Setup parameters for call to function osal_start_timerEx
   \   000081   7C64         MOV     R4,#0x64
   \   000083   7D00         MOV     R5,#0x0
   \   000085   7A00         MOV     R2,#0x0
   \   000087   FB           MOV     R3,A
   \   000088   90....       MOV     DPTR,#ZDAppTaskID
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F9           MOV     R1,A
   \   00008D   12....       LCALL   ??osal_start_timerEx?relay
   \   000090   8008         SJMP    ??ZDSecMgrDeviceCtrlHandler_6
   1629            }
   1630            else
   1631            {
   1632              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000092                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   000092   E0           MOVX    A,@DPTR
   \   000093   FA           MOV     R2,A
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   FB           MOV     R3,A
   \   000097   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1633            }
   1634          }
   \                     ??ZDSecMgrDeviceCtrlHandler_6:
   \   00009A   7F01         MOV     R7,#0x1
   \   00009C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1635          
   1636          /******************************************************************************
   1637           * @fn          ZDSecMgrDeviceCtrlSetup
   1638           *
   1639           * @brief       Setup device control.
   1640           *
   1641           * @param       device - [in] ZDSecMgrDevice_t, device info
   1642           *
   1643           * @return      ZStatus_t
   1644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1645          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1646          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1647            if ( device->ctrl != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   2408         ADD     A,#0x8
   \   000007   F8           MOV     R0,A
   \   000008   EB           MOV     A,R3
   \   000009   3400         ADDC    A,#0x0
   \   00000B   F9           MOV     R1,A
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FC           MOV     R4,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FD           MOV     R5,A
   \   000015   EC           MOV     A,R4
   \   000016   4D           ORL     A,R5
   \   000017   6035         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1648            {
   1649              if ( device->secure == FALSE )
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   7011         JNZ     ??ZDSecMgrDeviceCtrlSetup_1
   1650              {
   1651                // send the master key data to the joining device
   1652                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F583         MOV     DPH,A
   \   000030   8882         MOV     DPL,R0
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   7402         MOV     A,#0x2
   \   000039   800F         SJMP    ??ZDSecMgrDeviceCtrlSetup_2
   1653              }
   1654              else
   1655              {
   1656                // start SKKE
   1657                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F583         MOV     DPH,A
   \   000041   8882         MOV     DPL,R0
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   00004A   F0           MOVX    @DPTR,A
   1658              }
   1659          
   1660              ZDSecMgrDeviceCtrlHandler( device );
   \   00004B                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00004B   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1661            }
   1662          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00004E   D083         POP     DPH
   \   000050   D082         POP     DPL
   \   000052   02....       LJMP    ?BRET
   1663          
   1664          /******************************************************************************
   1665           * @fn          ZDSecMgrDeviceCtrlUpdate
   1666           *
   1667           * @brief       Update control data.
   1668           *
   1669           * @param       extAddr - [in] EXT address
   1670           * @param       state   - [in] new control state
   1671           *
   1672           * @return      none
   1673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1674          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1675          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1676            ZDSecMgrEntry_t* entry;
   1677            ZDSecMgrCtrl_t*  ctrl;
   1678          
   1679          
   1680            // lookup device entry data
   1681            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   AC82         MOV     R4,DPL
   \   000013   AD83         MOV     R5,DPH
   \   000015   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   1682          
   1683            if ( entry != NULL )
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   49           ORL     A,R1
   \   000024   6066         JZ      ??ZDSecMgrDeviceCtrlUpdate_0
   1684            {
   1685              // lookup device control data
   1686              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000026                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   AC82         MOV     R4,DPL
   \   00002E   AD83         MOV     R5,DPH
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FA           MOV     R2,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1687          
   1688              // make sure control data is valid
   1689              if ( ctrl != NULL )
   \   00003D   85..82       MOV     DPL,?XSP + 0
   \   000040   85..83       MOV     DPH,?XSP + 1
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F8           MOV     R0,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   E8           MOV     A,R0
   \   000049   49           ORL     A,R1
   \   00004A   6040         JZ      ??ZDSecMgrDeviceCtrlUpdate_0
   1690              {
   1691                // possible state transitions
   1692                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2405         ADD     A,#0x5
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   3400         ADDC    A,#0x0
   \   00005A   F9           MOV     R1,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   8983         MOV     DPH,R1
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   6404         XRL     A,#0x4
   \   000062   7028         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1693                {
   1694                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000064   7405         MOV     A,#0x5
   \   000066   6E           XRL     A,R6
   \   000067   7004         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1695                  {
   1696                    // send the network key
   1697                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000069   7407         MOV     A,#0x7
   \   00006B   8007         SJMP    ??ZDSecMgrDeviceCtrlUpdate_2
   1698                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1699                  }
   1700                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00006D   7406         MOV     A,#0x6
   \   00006F   6E           XRL     A,R6
   \   000070   701A         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1701                  {
   1702                    // force default timeout in order to cleanup control logic
   1703                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000072   7406         MOV     A,#0x6
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   000074   F0           MOVX    @DPTR,A
   1704                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000075   85..82       MOV     DPL,?XSP + 0
   \   000078   85..83       MOV     DPH,?XSP + 1
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F583         MOV     DPH,A
   \   000081   8882         MOV     DPL,R0
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   7401         MOV     A,#0x1
   \   00008B   F0           MOVX    @DPTR,A
   1705                  }
   1706                }
   1707                // timer should be active
   1708              }
   1709            }
   1710          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   00008C   7404         MOV     A,#0x4
   \   00008E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000091   7F01         MOV     R7,#0x1
   \   000093   02....       LJMP    ?BANKED_LEAVE_XDATA
   1711          
   1712          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1713          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1714          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1715            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1716            {
   1717              if ( initiator == TRUE )
   1718              {
   1719                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1720              }
   1721            }
   1722          }
   \   000000   02....       LJMP    ?BRET
   1723          
   1724          /******************************************************************************
   1725           * @fn          ZDSecMgrDeviceRemove
   1726           *
   1727           * @brief       Remove device from network.
   1728           *
   1729           * @param       device - [in] ZDSecMgrDevice_t, device info
   1730           *
   1731           * @return      none
   1732           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1733          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1734          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1735            APSME_RemoveDeviceReq_t remDevReq;
   1736            NLME_LeaveReq_t         leaveReq;
   1737            associated_devices_t*   assoc;
   1738          
   1739          
   1740            // check if parent, remove the device
   1741            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000A   EA           MOV     A,R2
   \   00000B   2402         ADD     A,#0x2
   \   00000D   F8           MOV     R0,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   FE           MOV     R6,A
   \   000014   E9           MOV     A,R1
   \   000015   FF           MOV     R7,A
   \   000016   EA           MOV     A,R2
   \   000017   2404         ADD     A,#0x4
   \   000019   08           INC     R0
   \   00001A   08           INC     R0
   \   00001B   EB           MOV     A,R3
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   F9           MOV     R1,A
   \   00001F   88..         MOV     ?V0 + 0,R0
   \   000021   89..         MOV     ?V0 + 1,R1
   \   000023   8882         MOV     DPL,R0
   \   000025   F583         MOV     DPH,A
   \   000027   C082         PUSH    DPL
   \   000029   C083         PUSH    DPH
   \   00002B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002B   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00002E   8A..         MOV     ?V0 + 2,R2
   \   000030   8B..         MOV     ?V0 + 3,R3
   \   000032   D083         POP     DPH
   \   000034   D082         POP     DPL
   \   000036   E0           MOVX    A,@DPTR
   \   000037   65..         XRL     A,?V0 + 2
   \   000039   7004         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00003F   7074         JNZ     ??ZDSecMgrDeviceRemove_1
   1742            {
   1743              // this is the parent of the device
   1744              leaveReq.extAddr        = device->extAddr;
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   E8           MOV     A,R0
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   E9           MOV     A,R1
   \   000054   F0           MOVX    @DPTR,A
   1745              leaveReq.removeChildren = FALSE;
   \   000055   7402         MOV     A,#0x2
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E4           CLR     A
   \   00005B   F0           MOVX    @DPTR,A
   1746              leaveReq.rejoin         = FALSE;
   \   00005C   7403         MOV     A,#0x3
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   E4           CLR     A
   \   000062   F0           MOVX    @DPTR,A
   1747          
   1748              // find child association
   1749              assoc = AssocGetWithExt( device->extAddr );
   \   000063                ; Setup parameters for call to function AssocGetWithExt
   \   000063   8E82         MOV     DPL,R6
   \   000065   8F83         MOV     DPH,R7
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   FB           MOV     R3,A
   \   00006C   12....       LCALL   ??AssocGetWithExt?relay
   \   00006F   8A..         MOV     ?V0 + 0,R2
   \   000071   8B..         MOV     ?V0 + 1,R3
   \   000073   A8..         MOV     R0,?V0 + 0
   \   000075   A9..         MOV     R1,?V0 + 1
   1750          
   1751              if ( ( assoc != NULL                            ) &&
   1752                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1753                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000077   E8           MOV     A,R0
   \   000078   49           ORL     A,R1
   \   000079   606E         JZ      ??ZDSecMgrDeviceRemove_2
   \   00007B   8882         MOV     DPL,R0
   \   00007D   8983         MOV     DPH,R1
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   14           DEC     A
   \   000085   C3           CLR     C
   \   000086   9404         SUBB    A,#0x4
   \   000088   505F         JNC     ??ZDSecMgrDeviceRemove_2
   1754              {
   1755                // check if associated device is authenticated
   1756                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00008A   8882         MOV     DPL,R0
   \   00008C   8983         MOV     DPH,R1
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   A2E3         MOV     C,0xE0 /* A   */.3
   \   000096   7404         MOV     A,#0x4
   \   000098   5006         JNC     ??ZDSecMgrDeviceRemove_3
   1757                {
   1758                  leaveReq.silent = FALSE;
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   E4           CLR     A
   \   00009E   8005         SJMP    ??ZDSecMgrDeviceRemove_4
   1759                }
   1760                else
   1761                {
   1762                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000A5   F0           MOVX    @DPTR,A
   1763                }
   1764          
   1765                NLME_LeaveReq( &leaveReq );
   \   0000A6                ; Setup parameters for call to function NLME_LeaveReq
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   AA82         MOV     R2,DPL
   \   0000AE   AB83         MOV     R3,DPH
   \   0000B0   12....       LCALL   ??NLME_LeaveReq?relay
   \   0000B3   8034         SJMP    ??ZDSecMgrDeviceRemove_2
   1766              }
   1767            }
   1768            else
   1769            {
   1770              // this is not the parent of the device
   1771              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000B5   85..82       MOV     DPL,?V0 + 0
   \   0000B8   85..83       MOV     DPH,?V0 + 1
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   F8           MOV     R0,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F9           MOV     R1,A
   \   0000C0   7405         MOV     A,#0x5
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   E8           MOV     A,R0
   \   0000C6   F0           MOVX    @DPTR,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E9           MOV     A,R1
   \   0000C9   F0           MOVX    @DPTR,A
   1772              remDevReq.childExtAddr = device->extAddr;
   \   0000CA   8E82         MOV     DPL,R6
   \   0000CC   8F83         MOV     DPH,R7
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   F8           MOV     R0,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   F9           MOV     R1,A
   \   0000D3   7407         MOV     A,#0x7
   \   0000D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D8   E8           MOV     A,R0
   \   0000D9   F0           MOVX    @DPTR,A
   \   0000DA   A3           INC     DPTR
   \   0000DB   E9           MOV     A,R1
   \   0000DC   F0           MOVX    @DPTR,A
   1773          
   1774              APSME_RemoveDeviceReq( &remDevReq );
   \   0000DD                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000DD   7405         MOV     A,#0x5
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   AA82         MOV     R2,DPL
   \   0000E4   AB83         MOV     R3,DPH
   \   0000E6   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1775            }
   1776          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000E9   7409         MOV     A,#0x9
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EE   7F04         MOV     R7,#0x4
   \   0000F0   02....       LJMP    ?BANKED_LEAVE_XDATA
   1777          
   1778          /******************************************************************************
   1779           * @fn          ZDSecMgrDeviceValidateSKKE
   1780           *
   1781           * @brief       Decide whether device is allowed for SKKE.
   1782           *
   1783           * @param       device - [in] ZDSecMgrDevice_t, device info
   1784           *
   1785           * @return      ZStatus_t
   1786           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1787          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1788          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1789            ZStatus_t status;
   1790            uint16    ami;
   1791            uint8*    key;
   1792          
   1793          
   1794            // get EXT address
   1795            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   1796          
   1797            if ( status == ZSuccess )
   \   000027   702C         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1798            {
   1799              // get MASTER key
   1800              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000029                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000029   7402         MOV     A,#0x2
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   AC82         MOV     R4,DPL
   \   000030   AD83         MOV     R5,DPH
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000040   E9           MOV     A,R1
   1801          
   1802              if ( status == ZSuccess )
   \   000041   7012         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1803              {
   1804              //  // check if initiator is Trust Center
   1805              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1806              //  {
   1807              //    // verify NWK key not sent
   1808              //    // devtag.todo
   1809              //    // temporary - add device to internal data
   1810              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1811              //  }
   1812              //  else
   1813              //  {
   1814              //    // initiator not Trust Center - End to End SKKE - set policy
   1815              //    // for accepting an SKKE initiation
   1816              //    // temporary - add device to internal data
   1817              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1818              //  }
   1819                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000043                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FC           MOV     R4,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   FD           MOV     R5,A
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   1820              }
   1821            }
   1822          
   1823            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   7F01         MOV     R7,#0x1
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1824          }
   1825          
   1826          /******************************************************************************
   1827           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1828           *
   1829           * @brief       Decide whether device is allowed.
   1830           *
   1831           * @param       device - [in] ZDSecMgrDevice_t, device info
   1832           *
   1833           * @return      ZStatus_t
   1834           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1835          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1836          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1837          
   1838            ZStatus_t status;
   1839            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1840          
   1841            (void)device;  // Intentionally unreferenced parameter
   1842            
   1843            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1844            // the trust center to reject any newly joining devices by sending
   1845            // Remove-device to the parents.
   1846            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1847            {
   1848              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1849            }
   1850          
   1851          
   1852          
   1853          #if 0  // Taken out because the following functionality is only used for test
   1854                 // purpose. A more efficient (above) way is used. It can be put
   1855                 // back in if customers request for a white/black list feature.
   1856                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1857          
   1858            // The following code processes the device black list (stored device list)
   1859            // If the joining device is not part of the forbidden device list
   1860            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1861            // will send Remove-device and ban the device from joining.
   1862          
   1863            uint8     index;
   1864            uint8*    restricted;
   1865          
   1866            // Look through the stored device list - used for restricted devices
   1867            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1868            {
   1869              restricted = ZDSecMgrStoredDeviceList[index];
   1870          
   1871              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1872              {
   1873                // return as unknown device in regards to validation
   1874                status = ZNwkUnknownDevice;
   1875          
   1876                // break from loop
   1877                index = ZDSECMGR_STORED_DEVICES;
   1878              }
   1879            }
   1880          
   1881          #endif
   1882          
   1883            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
   1884          }
   1885          
   1886          /******************************************************************************
   1887           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1888           *
   1889           * @brief       Decide whether device is allowed.
   1890           *
   1891           * @param       device - [in] ZDSecMgrDevice_t, device info
   1892           *
   1893           * @return      ZStatus_t
   1894           */
   1895          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1897          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903          //  // check for pre configured setting
   1904          //  if ( device->secure == TRUE )
   1905          //  {
   1906          //    // get EXT address and MASTER key
   1907          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          //
   1909          //    if ( status == ZSuccess )
   1910          //    {
   1911          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912          //    }
   1913          //  }
   1914          //  else
   1915          //  {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              //status = ZNwkUnknownDevice;
   1922          
   1923              // set status based on policy
   1924              status = ZSuccess; // ZNwkUnknownDevice;
   1925          
   1926              // get key based on policy
   1927              key = ZDSecMgrTCMasterKey;
   1928          
   1929              // if policy, store new EXT address
   1930              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   F8           MOV     R0,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   F9           MOV     R1,A
   \   000016   88..         MOV     ?V0 + 0,R0
   \   000018   89..         MOV     ?V0 + 1,R1
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   8582..       MOV     ?V0 + 2,DPL
   \   000023   8583..       MOV     ?V0 + 3,DPH
   \   000026   78..         MOV     R0,#?V0 + 2
   \   000028   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002B   85..82       MOV     DPL,?V0 + 0
   \   00002E   8983         MOV     DPH,R1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FC           MOV     R4,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FD           MOV     R5,A
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FA           MOV     R2,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   F5..         MOV     ?V0 + 2,A
   1931          
   1932              // set the key
   1933              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000049                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000049   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   00004B   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00004D   85..82       MOV     DPL,?V0 + 0
   \   000050   85..83       MOV     DPH,?V0 + 1
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FA           MOV     R2,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   FB           MOV     R3,A
   \   000058   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   1934          //  }
   1935          
   1936            // if EXT address and MASTER key available -- add device
   1937            if ( status == ZSuccess )
   \   00005B   E5..         MOV     A,?V0 + 2
   \   00005D   7015         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1938            {
   1939              // add device to internal data - with control
   1940              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00005F                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FC           MOV     R4,A
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FD           MOV     R5,A
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FB           MOV     R3,A
   \   00006E   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   000071   E9           MOV     A,R1
   \   000072   F5..         MOV     ?V0 + 2,A
   1941            }
   1942          
   1943            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000074   A9..         MOV     R1,?V0 + 2
   \   000076   7402         MOV     A,#0x2
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B   7F04         MOV     R7,#0x4
   \   00007D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1944          }
   1945          //devtag.pro.security
   1946          #if 0
   1947          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1948          {
   1949            ZStatus_t status;
   1950            uint16    ami;
   1951            uint8*    key;
   1952          
   1953          
   1954            // check for pre configured setting
   1955            if ( device->secure == TRUE )
   1956            {
   1957              // get EXT address and MASTER key
   1958              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1959          
   1960              if ( status == ZSuccess )
   1961              {
   1962                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1963              }
   1964            }
   1965            else
   1966            {
   1967              // implement EXT address and MASTER key policy here -- the total number of
   1968              // Security Manager entries should never exceed the number of EXT addresses
   1969              // and MASTER keys available
   1970          
   1971              // set status based on policy
   1972              status = ZSuccess; // ZNwkUnknownDevice;
   1973          
   1974              // get the address index
   1975              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1976              {
   1977                // if policy, store new EXT address
   1978                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1979              }
   1980          
   1981              // get the address index
   1982              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1983              {
   1984                // if policy, store new key -- NULL will zero key
   1985                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1986              }
   1987            }
   1988          
   1989            // if EXT address and MASTER key available -- add device
   1990            if ( status == ZSuccess )
   1991            {
   1992              // add device to internal data - with control
   1993              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1994            }
   1995          
   1996            return status;
   1997          }
   1998          #endif
   1999          
   2000          /******************************************************************************
   2001           * @fn          ZDSecMgrDeviceValidate
   2002           *
   2003           * @brief       Decide whether device is allowed.
   2004           *
   2005           * @param       device - [in] ZDSecMgrDevice_t, device info
   2006           *
   2007           * @return      ZStatus_t
   2008           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2009          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   2010          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2011            ZStatus_t status;
   2012          
   2013          
   2014            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   701F         JNZ     ??ZDSecMgrDeviceValidate_0
   2015            {
   2016              // device may be joining with a secure flag but it is ultimately the Trust
   2017              // Center that decides -- check if expected pre configured device --
   2018              // override settings
   2019              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV     A,R2
   \   00000D   2406         ADD     A,#0x6
   \   00000F   F8           MOV     R0,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#zgPreConfigKeys
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   2020              {
   2021                device->secure = TRUE;
   \   000020   7401         MOV     A,#0x1
   \   000022   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   2022              }
   2023              else
   2024              {
   2025                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000024   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000025   F0           MOVX    @DPTR,A
   2026              }
   2027          
   2028              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2029              {
   2030                status = ZDSecMgrDeviceValidateCM( device );
   2031              }
   2032              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2033              {
   2034                status = ZDSecMgrDeviceValidateRM( device );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000026   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   000029   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   2035              }
   2036            }
   2037            else
   2038            {
   2039              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV     R1,#-0x38
   2040            }
   2041          
   2042            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   D083         POP     DPH
   \   00002F   D082         POP     DPL
   \   000031   02....       LJMP    ?BRET
   2043          }
   2044          
   2045          /******************************************************************************
   2046           * @fn          ZDSecMgrDeviceJoin
   2047           *
   2048           * @brief       Try to join this device.
   2049           *
   2050           * @param       device - [in] ZDSecMgrDevice_t, device info
   2051           *
   2052           * @return      ZStatus_t
   2053           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2054          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2055          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2056            ZStatus_t status;
   2057            uint16    ami;
   2058          
   2059            // attempt to validate device
   2060            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   000011   E9           MOV     A,R1
   \   000012   F5..         MOV     ?V0 + 0,A
   2061          
   2062            if ( status == ZSuccess )
   \   000014   7039         JNZ     ??ZDSecMgrDeviceJoin_0
   2063            {
   2064              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2065              {
   2066                ZDSecMgrDeviceCtrlSetup( device );
   2067              }
   2068              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2069              {
   2070                // Add the device to the address manager
   2071                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   8582..       MOV     ?V0 + 0,DPL
   \   00001F   8583..       MOV     ?V0 + 1,DPH
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FC           MOV     R4,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FD           MOV     R5,A
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FA           MOV     R2,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FB           MOV     R3,A
   \   00003B   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   2072                //send the nwk key data to the joining device
   2073                status = ZDSecMgrSendNwkKey( device );
   \   000043                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000043   EE           MOV     A,R6
   \   000044   FA           MOV     R2,A
   \   000045   EF           MOV     A,R7
   \   000046   FB           MOV     R3,A
   \   000047   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00004A   E9           MOV     A,R1
   \   00004B   F5..         MOV     ?V0 + 0,A
   \   00004D   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2074              }
   2075            }
   2076            else
   2077            {
   2078              // not allowed, remove the device
   2079              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00004F                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004F   EE           MOV     A,R6
   \   000050   FA           MOV     R2,A
   \   000051   EF           MOV     A,R7
   \   000052   FB           MOV     R3,A
   \   000053   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2080            }
   2081          
   2082            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000056   A9..         MOV     R1,?V0 + 0
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005D   7F02         MOV     R7,#0x2
   \   00005F   02....       LJMP    ?BANKED_LEAVE_XDATA
   2083          }
   2084          
   2085          /******************************************************************************
   2086           * @fn          ZDSecMgrDeviceJoinDirect
   2087           *
   2088           * @brief       Try to join this device as a direct child.
   2089           *
   2090           * @param       device - [in] ZDSecMgrDevice_t, device info
   2091           *
   2092           * @return      ZStatus_t
   2093           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2094          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2095          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2096            ZStatus_t status;
   2097          
   2098            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2099          
   2100            if ( status == ZSuccess )
   \   00000F   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2101            {
   2102              // set association status to authenticated
   2103              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FA           MOV     R2,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??AssocGetWithShort?relay
   \   00001D   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2104            }
   2105          
   2106            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000020   A9..         MOV     R1,?V0 + 0
   \   000022   7F01         MOV     R7,#0x1
   \   000024   02....       LJMP    ?BANKED_LEAVE_XDATA
   2107          }
   2108          
   2109          /******************************************************************************
   2110           * @fn          ZDSecMgrDeviceJoinFwd
   2111           *
   2112           * @brief       Forward join to Trust Center.
   2113           *
   2114           * @param       device - [in] ZDSecMgrDevice_t, device info
   2115           *
   2116           * @return      ZStatus_t
   2117           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2118          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2119          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2120            ZStatus_t               status;
   2121            APSME_UpdateDeviceReq_t req;
   2122          
   2123          
   2124            // forward any joining device to the Trust Center -- the Trust Center will
   2125            // decide if the device is allowed to join
   2126            status = ZSuccess;
   2127          
   2128            // forward authorization to the Trust Center
   2129            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
   2130            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E8           MOV     A,R0
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E9           MOV     A,R1
   \   000025   F0           MOVX    @DPTR,A
   2131            req.devExtAddr = device->extAddr;
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F9           MOV     R1,A
   \   000031   7404         MOV     A,#0x4
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E8           MOV     A,R0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E9           MOV     A,R1
   \   00003A   F0           MOVX    @DPTR,A
   2132          
   2133            // set security status, option for router to reject if policy set
   2134            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   00003B   EA           MOV     A,R2
   \   00003C   2407         ADD     A,#0x7
   \   00003E   F582         MOV     DPL,A
   \   000040   EB           MOV     A,R3
   \   000041   3400         ADDC    A,#0x0
   \   000043   F583         MOV     DPH,A
   \   000045   E0           MOVX    A,@DPTR
   \   000046   A2E7         MOV     C,0xE0 /* A   */.7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2135            {
   2136              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00004B   A2E6         MOV     C,0xE0 /* A   */.6
   \   00004D   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2137              {
   2138                if ( device->secure == TRUE )
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   6401         XRL     A,#0x1
   \   00005C   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2139                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   00005E   7406         MOV     A,#0x6
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   7404         MOV     A,#0x4
   \   000065   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2140                else
   2141                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000067   7406         MOV     A,#0x6
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   7407         MOV     A,#0x7
   \   00006E   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2142              }
   2143              else
   2144                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000070   7406         MOV     A,#0x6
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   7405         MOV     A,#0x5
   \   000077   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2145            }
   2146            else
   2147            {
   2148              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000079   A2E6         MOV     C,0xE0 /* A   */.6
   \   00007B   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2149              {
   2150                if ( device->secure == TRUE )
   \   00007D   8A82         MOV     DPL,R2
   \   00007F   8B83         MOV     DPH,R3
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   6401         XRL     A,#0x1
   \   00008A   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2151                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   00008C   7406         MOV     A,#0x6
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   E4           CLR     A
   \   000092   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2152                else
   2153                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   7403         MOV     A,#0x3
   \   00009B   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2154              }
   2155              else
   2156                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   00009D   7406         MOV     A,#0x6
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   0000A4   F0           MOVX    @DPTR,A
   2157            }
   2158          
   2159            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2160              req.apsSecure = TRUE;
   2161            else
   2162              req.apsSecure = FALSE;
   \   0000A5   7407         MOV     A,#0x7
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   E4           CLR     A
   \   0000AB   F0           MOVX    @DPTR,A
   2163          
   2164            // send and APSME_UPDATE_DEVICE request to the trust center
   2165            status = APSME_UpdateDeviceReq( &req );
   2166          
   2167            return status;
   \   0000AC                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000AC   85..82       MOV     DPL,?XSP + 0
   \   0000AF   85..83       MOV     DPH,?XSP + 1
   \   0000B2   AA82         MOV     R2,DPL
   \   0000B4   AB83         MOV     R3,DPH
   \   0000B6   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   0000B9   7408         MOV     A,#0x8
   \   0000BB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BE   D083         POP     DPH
   \   0000C0   D082         POP     DPL
   \   0000C2   02....       LJMP    ?BRET
   2168          }
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrDeviceNew
   2172           *
   2173           * @brief       Process a new device.
   2174           *
   2175           * @param       device - [in] ZDSecMgrDevice_t, device info
   2176           *
   2177           * @return      ZStatus_t
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2180          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2181            ZStatus_t status;
   2182          
   2183            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2184            {
   2185              // try to join this device
   2186              status = ZDSecMgrDeviceJoinDirect( joiner );
   2187            }
   2188            else
   2189            {
   2190              status = ZDSecMgrDeviceJoinFwd( joiner );
   2191            }
   2192          
   2193            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2194          }
   2195          
   2196          /******************************************************************************
   2197           * @fn          ZDSecMgrAssocDeviceAuth
   2198           *
   2199           * @brief       Set associated device status to authenticated
   2200           *
   2201           * @param       assoc - [in, out] associated_devices_t
   2202           *
   2203           * @return      none
   2204           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2205          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2206          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2207            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2208            {
   2209              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2210            }
   2211          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2212          
   2213          /******************************************************************************
   2214           * @fn          ZDSecMgrAuthInitiate
   2215           *
   2216           * @brief       Initiate entity authentication
   2217           *
   2218           * @param       responder - [in] responder EXT address
   2219           *
   2220           * @return      none
   2221           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2222          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2223          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2224            APSME_AuthenticateReq_t req;
   2225          
   2226          
   2227            // make sure NWK address is available
   2228            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   6027         JZ      ??ZDSecMgrAuthInitiate_0
   2229            {
   2230              // set request fields
   2231              req.extAddr   = responder;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   2232              req.action    = APSME_EA_INITIATE;
   \   000028   7406         MOV     A,#0x6
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
   2233              req.challenge = NULL;
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   F0           MOVX    @DPTR,A
   2234          
   2235              // start EA processing
   2236              APSME_AuthenticateReq( &req );
   \   000038                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   AA82         MOV     R2,DPL
   \   000040   AB83         MOV     R3,DPH
   \   000042   12....       LCALL   ??APSME_AuthenticateReq?relay
   2237            }
   2238          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000045   7407         MOV     A,#0x7
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   7F01         MOV     R7,#0x1
   \   00004C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2239          
   2240          /******************************************************************************
   2241           * @fn          ZDSecMgrAuthNwkKey
   2242           *
   2243           * @brief       Handle next step in authentication process
   2244           *
   2245           * @param       none
   2246           *
   2247           * @return      none
   2248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2249          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2250          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2251            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2252            {
   2253              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2254              {
   2255                uint8 parent[Z_EXTADDR_LEN];
   2256          
   2257                // get parent's EXT address
   2258                NLME_GetCoordExtAddr( parent );
   2259          
   2260                // begin entity authentication with parent
   2261                ZDSecMgrAuthInitiate( parent );
   2262              }
   2263              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2264              {
   2265                // inform ZDO that device has been authenticated
   2266                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   2267              }
   2268            }
   2269          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   2270          
   2271          /******************************************************************************
   2272           * PUBLIC FUNCTIONS
   2273           */
   2274          /******************************************************************************
   2275           * @fn          ZDSecMgrInit
   2276           *
   2277           * @brief       Initialize ZigBee Device Security Manager.
   2278           *
   2279           * @param       state - device initialization state
   2280           *
   2281           * @return      none
   2282           */
   2283          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2284          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2285          void ZDSecMgrAddrMgrCB( uint8           update,
   2286                                  AddrMgrEntry_t* newEntry,
   2287                                  AddrMgrEntry_t* oldEntry )
   2288          {
   2289            (void)update;
   2290            (void)newEntry;
   2291            (void)oldEntry;
   2292          }
   2293          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2294          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2295          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   2296          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2297            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2298                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2299            {
   2300              // initialize sub modules
   2301              ZDSecMgrMasterKeyInit();
   2302              ZDSecMgrEntryInit(state);
   2303          
   2304              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2305              {
   2306                ZDSecMgrCtrlInit();
   2307              }
   2308          
   2309              // register with Address Manager
   2310              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2311              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2312              #endif
   2313            }
   2314          
   2315            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2316            {
   2317              // configure SKA slot data
   2318              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2319            }
   2320            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2321            {
   2322              APSME_TCLinkKeyInit();  
   2323              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2324            
   2325            }
   2326          
   2327            if ( ZG_SECURE_ENABLED )
   2328            {
   2329              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2330              {
   2331                // setup joining permissions
   2332                ZDSecMgrPermitJoiningEnabled = TRUE;
   2333                ZDSecMgrPermitJoiningTimed   = FALSE;
   2334              }
   2335            }
   2336          
   2337            // configure security based on security mode and type of device
   2338            ZDSecMgrConfig();
   \   000004                ; Setup parameters for call to function ZDSecMgrConfig
   \   000004   12....       LCALL   ??ZDSecMgrConfig?relay
   2339          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2340          
   2341          /******************************************************************************
   2342           * @fn          ZDSecMgrConfig
   2343           *
   2344           * @brief       Configure ZigBee Device Security Manager.
   2345           *
   2346           * @param       none
   2347           *
   2348           * @return      none
   2349           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2350          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   2351          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2352            if ( ZG_SECURE_ENABLED )
   2353            {
   2354              SSP_Init();
   2355          
   2356              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2357                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2358              {
   2359                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2360                {
   2361                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2362                  APSME_SecurityCM_CD();
   2363                }
   2364                else if ( ZSTACK_ROUTER_BUILD )
   2365                {
   2366                  // COMMERCIAL MODE - ROUTER DEVICE
   2367                  APSME_SecurityCM_RD();
   2368                }
   2369                else
   2370                {
   2371                  // COMMERCIAL MODE - END DEVICE
   2372                  APSME_SecurityCM_ED();
   2373                }
   2374              }
   2375              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2376              {
   2377                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2378                {
   2379                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2380                  APSME_SecurityRM_CD();
   2381                }
   2382                else if ( ZSTACK_ROUTER_BUILD )
   2383                {
   2384                  // RESIDENTIAL MODE - ROUTER DEVICE
   2385                  APSME_SecurityRM_RD();
   2386                }
   2387                else
   2388                {
   2389                  // RESIDENTIAL MODE - END DEVICE
   2390                  APSME_SecurityRM_ED();
   2391                }
   2392              }
   2393            }
   2394            else
   2395            {
   2396              // NO SECURITY
   2397              APSME_SecurityNM();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   2398            }
   2399          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2400          
   2401          /******************************************************************************
   2402           * @fn          ZDSecMgrPermitJoining
   2403           *
   2404           * @brief       Process request to change joining permissions.
   2405           *
   2406           * @param       duration - [in] timed duration for join in seconds
   2407           *                         - 0x00 not allowed
   2408           *                         - 0xFF allowed without timeout
   2409           *
   2410           * @return      uint8 - success(TRUE:FALSE)
   2411           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2412          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2413          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2414            uint8 accept;
   2415          
   2416          
   2417            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   2418          
   2419            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ      ??ZDSecMgrPermitJoining_0
   2420            {
   2421              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   2422          
   2423              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   68           XRL     A,R0
   \   000017   6009         JZ      ??ZDSecMgrPermitJoining_1
   2424              {
   2425                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrPermitJoining_2
   2426              }
   2427            }
   2428            else
   2429            {
   2430              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX    @DPTR,A
   2431            }
   2432          
   2433            accept = TRUE;
   2434          
   2435            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV     R1,#0x1
   \   000024   D083         POP     DPH
   \   000026   D082         POP     DPL
   \   000028   02....       LJMP    ?BRET
   2436          }
   2437          
   2438          /******************************************************************************
   2439           * @fn          ZDSecMgrPermitJoiningTimeout
   2440           *
   2441           * @brief       Process permit joining timeout
   2442           *
   2443           * @param       none
   2444           *
   2445           * @return      none
   2446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2447          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2448          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2449            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2450            {
   2451              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   2452              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2453            }
   2454          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2455          
   2456          /******************************************************************************
   2457           * @fn          ZDSecMgrNewDeviceEvent
   2458           *
   2459           * @brief       Process a the new device event, if found reset new device
   2460           *              event/timer.
   2461           *
   2462           * @param       none
   2463           *
   2464           * @return      uint8 - found(TRUE:FALSE)
   2465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2466          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2467          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2468            uint8                 found;
   2469            ZDSecMgrDevice_t      device;
   2470            AddrMgrEntry_t        addrEntry;
   2471            associated_devices_t* assoc;
   2472            ZStatus_t             status;
   2473          
   2474            // initialize return results
   2475            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2476          
   2477            // look for device in the security init state
   2478            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2479          
   2480            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2481            {
   2482              // device found
   2483              found = TRUE;
   \   000021   75..01       MOV     ?V0 + 0,#0x1
   2484          
   2485              // check for preconfigured security
   2486              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2487              {
   2488                // set association status to authenticated
   2489                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2490              }
   2491          
   2492              // set up device info
   2493              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   2494              addrEntry.index = assoc->addrIdx;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7415         MOV     A,#0x15
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E8           MOV     A,R0
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   E9           MOV     A,R1
   \   00004A   F0           MOVX    @DPTR,A
   2495              AddrMgrEntryGet( &addrEntry );
   \   00004B                ; Setup parameters for call to function AddrMgrEntryGet
   \   00004B   740A         MOV     A,#0xa
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AA82         MOV     R2,DPL
   \   000052   AB83         MOV     R3,DPH
   \   000054   12....       LCALL   ??AddrMgrEntryGet?relay
   2496          
   2497              device.nwkAddr    = assoc->shortAddr;
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   85..82       MOV     DPL,?XSP + 0
   \   000063   85..83       MOV     DPH,?XSP + 1
   \   000066   E8           MOV     A,R0
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   E9           MOV     A,R1
   \   00006A   F0           MOVX    @DPTR,A
   2498              device.extAddr    = addrEntry.extAddr;
   \   00006B   740D         MOV     A,#0xd
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   A882         MOV     R0,DPL
   \   000072   A983         MOV     R1,DPH
   \   000074   7402         MOV     A,#0x2
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E8           MOV     A,R0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E9           MOV     A,R1
   \   00007D   F0           MOVX    @DPTR,A
   2499              device.parentAddr = NLME_GetShortAddr();
   \   00007E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   EA           MOV     A,R2
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   EB           MOV     A,R3
   \   00008A   F0           MOVX    @DPTR,A
   2500              device.secure     = FALSE;
   \   00008B   7406         MOV     A,#0x6
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   E4           CLR     A
   \   000091   F0           MOVX    @DPTR,A
   2501              device.devStatus  = assoc->devStatus;
   \   000092   EE           MOV     A,R6
   \   000093   2405         ADD     A,#0x5
   \   000095   F8           MOV     R0,A
   \   000096   EF           MOV     A,R7
   \   000097   3400         ADDC    A,#0x0
   \   000099   F9           MOV     R1,A
   \   00009A   E8           MOV     A,R0
   \   00009B   FE           MOV     R6,A
   \   00009C   E9           MOV     A,R1
   \   00009D   FF           MOV     R7,A
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   C0E0         PUSH    A
   \   0000A5   7407         MOV     A,#0x7
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   D0E0         POP     A
   \   0000AC   F0           MOVX    @DPTR,A
   2502          
   2503              // process new device
   2504              status = ZDSecMgrDeviceNew( &device );
   \   0000AD                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   AA82         MOV     R2,DPL
   \   0000B5   AB83         MOV     R3,DPH
   \   0000B7   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   0000BA   E9           MOV     A,R1
   \   0000BB   F8           MOV     R0,A
   2505          
   2506              if ( status == ZSuccess )
   \   0000BC   700A         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2507              {
   2508                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000BE   8E82         MOV     DPL,R6
   \   0000C0   8F83         MOV     DPH,R7
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   C2E2         CLR     0xE0 /* A   */.2
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   8011         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2509              }
   2510              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000C8   74C8         MOV     A,#-0x38
   \   0000CA   68           XRL     A,R0
   \   0000CB   700C         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2511              {
   2512                AssocRemove( addrEntry.extAddr );
   \   0000CD                ; Setup parameters for call to function AssocRemove
   \   0000CD   740D         MOV     A,#0xd
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   AA82         MOV     R2,DPL
   \   0000D4   AB83         MOV     R3,DPH
   \   0000D6   12....       LCALL   ??AssocRemove?relay
   2513              }
   2514            }
   2515          
   2516            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000D9   A9..         MOV     R1,?V0 + 0
   \   0000DB   7417         MOV     A,#0x17
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   7F04         MOV     R7,#0x4
   \   0000E2   02....       LJMP    ?BANKED_LEAVE_XDATA
   2517          }
   2518          
   2519          /******************************************************************************
   2520           * @fn          ZDSecMgrEvent
   2521           *
   2522           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2523           *
   2524           * @param       none
   2525           *
   2526           * @return      none
   2527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2528          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2529          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2530            uint8            action;
   2531            uint8            restart;
   2532            uint16           index;
   2533            AddrMgrEntry_t   entry;
   2534            ZDSecMgrDevice_t device;
   2535          
   2536          
   2537            // verify data is available
   2538            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   7003         JNZ     $+5
   \   000016   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2539            {
   2540              action  = FALSE;
   \   000019   75..00       MOV     ?V0 + 0,#0x0
   2541              restart = FALSE;
   \   00001C   75..00       MOV     ?V0 + 1,#0x0
   2542          
   2543              // update all the counters
   2544              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \   000023   800B         SJMP    ??ZDSecMgrEvent_1
   2545              {
   2546                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   2547                {
   2548                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   2549                  {
   2550                    ZDSecMgrCtrlData[index].cntr--;
   2551                  }
   2552          
   2553                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   2554                  {
   2555                    action = TRUE;
   2556          
   2557                    // update from control data
   2558                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   2559                    device.secure     = ZDSecMgrCtrlData[index].secure;
   2560                    device.ctrl       = &ZDSecMgrCtrlData[index];
   2561          
   2562                    // set the user and address index
   2563                    entry.user  = ADDRMGR_USER_SECURITY;
   2564                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   2565          
   2566                    // get the address data
   2567                    AddrMgrEntryGet( &entry );
   2568          
   2569                    // set device address data
   2570                    device.nwkAddr = entry.nwkAddr;
   2571                    device.extAddr = entry.extAddr;
   2572          
   2573                    // update from entry data
   2574                    ZDSecMgrDeviceCtrlHandler( &device );
   2575                  }
   2576                  else
   2577                  {
   2578                    restart = TRUE;
   \                     ??ZDSecMgrEvent_2:
   \   000025   75..01       MOV     ?V0 + 1,#0x1
   2579                  }
   \                     ??ZDSecMgrEvent_3:
   \   000028   EE           MOV     A,R6
   \   000029   2401         ADD     A,#0x1
   \   00002B   0E           INC     R6
   \   00002C   EF           MOV     A,R7
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   FF           MOV     R7,A
   \                     ??ZDSecMgrEvent_1:
   \   000030   C3           CLR     C
   \   000031   EE           MOV     A,R6
   \   000032   9403         SUBB    A,#0x3
   \   000034   EF           MOV     A,R7
   \   000035   9400         SUBB    A,#0x0
   \   000037   4003         JC      $+5
   \   000039   02....       LJMP    ??ZDSecMgrEvent_4 & 0xFFFF
   \   00003C   EE           MOV     A,R6
   \   00003D   F8           MOV     R0,A
   \   00003E   EF           MOV     A,R7
   \   00003F   F9           MOV     R1,A
   \   000040   E8           MOV     A,R0
   \   000041   75F007       MOV     B,#0x7
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   AAF0         MOV     R2,B
   \   000048   75F007       MOV     B,#0x7
   \   00004B   E9           MOV     A,R1
   \   00004C   A4           MUL     AB
   \   00004D   2A           ADD     A,R2
   \   00004E   F9           MOV     R1,A
   \   00004F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000052   E0           MOVX    A,@DPTR
   \   000053   28           ADD     A,R0
   \   000054   FA           MOV     R2,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   39           ADDC    A,R1
   \   000058   FB           MOV     R3,A
   \   000059   8A82         MOV     DPL,R2
   \   00005B   8B83         MOV     DPH,R3
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   60C3         JZ      ??ZDSecMgrEvent_3
   \   000065   EA           MOV     A,R2
   \   000066   2406         ADD     A,#0x6
   \   000068   F582         MOV     DPL,A
   \   00006A   EB           MOV     A,R3
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F583         MOV     DPH,A
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   6003         JZ      ??ZDSecMgrEvent_5
   \   000072   E0           MOVX    A,@DPTR
   \   000073   14           DEC     A
   \   000074   F0           MOVX    @DPTR,A
   \                     ??ZDSecMgrEvent_5:
   \   000075   E5..         MOV     A,?V0 + 0
   \   000077   70AC         JNZ     ??ZDSecMgrEvent_2
   \   000079   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   28           ADD     A,R0
   \   00007E   F8           MOV     R0,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   39           ADDC    A,R1
   \   000082   F9           MOV     R1,A
   \   000083   8882         MOV     DPL,R0
   \   000085   8983         MOV     DPH,R1
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   7095         JNZ     ??ZDSecMgrEvent_2
   \   000090   75..01       MOV     ?V0 + 0,#0x1
   \   000093   8882         MOV     DPL,R0
   \   000095   8983         MOV     DPH,R1
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   FA           MOV     R2,A
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   FB           MOV     R3,A
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   EA           MOV     A,R2
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   EB           MOV     A,R3
   \   0000A7   F0           MOVX    @DPTR,A
   \   0000A8   8882         MOV     DPL,R0
   \   0000AA   8983         MOV     DPH,R1
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C0E0         PUSH    A
   \   0000B3   7406         MOV     A,#0x6
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   D0E0         POP     A
   \   0000BA   F0           MOVX    @DPTR,A
   \   0000BB   7408         MOV     A,#0x8
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   E8           MOV     A,R0
   \   0000C1   F0           MOVX    @DPTR,A
   \   0000C2   A3           INC     DPTR
   \   0000C3   E9           MOV     A,R1
   \   0000C4   F0           MOVX    @DPTR,A
   \   0000C5   740A         MOV     A,#0xa
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   7402         MOV     A,#0x2
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   8882         MOV     DPL,R0
   \   0000CF   8983         MOV     DPH,R1
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   F8           MOV     R0,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   F583         MOV     DPH,A
   \   0000D7   8882         MOV     DPL,R0
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   F8           MOV     R0,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F9           MOV     R1,A
   \   0000DE   7415         MOV     A,#0x15
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E8           MOV     A,R0
   \   0000E4   F0           MOVX    @DPTR,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E9           MOV     A,R1
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8                ; Setup parameters for call to function AddrMgrEntryGet
   \   0000E8   740A         MOV     A,#0xa
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   AA82         MOV     R2,DPL
   \   0000EF   AB83         MOV     R3,DPH
   \   0000F1   12....       LCALL   ??AddrMgrEntryGet?relay
   \   0000F4   740B         MOV     A,#0xb
   \   0000F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   F8           MOV     R0,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   F9           MOV     R1,A
   \   0000FE   85..82       MOV     DPL,?XSP + 0
   \   000101   85..83       MOV     DPH,?XSP + 1
   \   000104   E8           MOV     A,R0
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   E9           MOV     A,R1
   \   000108   F0           MOVX    @DPTR,A
   \   000109   740D         MOV     A,#0xd
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   A882         MOV     R0,DPL
   \   000110   A983         MOV     R1,DPH
   \   000112   7402         MOV     A,#0x2
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   E8           MOV     A,R0
   \   000118   F0           MOVX    @DPTR,A
   \   000119   A3           INC     DPTR
   \   00011A   E9           MOV     A,R1
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00011C   85..82       MOV     DPL,?XSP + 0
   \   00011F   85..83       MOV     DPH,?XSP + 1
   \   000122   AA82         MOV     R2,DPL
   \   000124   AB83         MOV     R3,DPH
   \   000126   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   000129   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2580                }
   2581              }
   2582          
   2583              // check for timer restart
   2584              if ( restart == TRUE )
   \                     ??ZDSecMgrEvent_4:
   \   00012C   7401         MOV     A,#0x1
   \   00012E   65..         XRL     A,?V0 + 1
   \   000130   7010         JNZ     ??ZDSecMgrEvent_0
   2585              {
   2586                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000132                ; Setup parameters for call to function osal_start_timerEx
   \   000132   7C64         MOV     R4,#0x64
   \   000134   7D00         MOV     R5,#0x0
   \   000136   7A00         MOV     R2,#0x0
   \   000138   7B01         MOV     R3,#0x1
   \   00013A   90....       MOV     DPTR,#ZDAppTaskID
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   F9           MOV     R1,A
   \   00013F   12....       LCALL   ??osal_start_timerEx?relay
   2587              }
   2588            }
   2589          }
   \                     ??ZDSecMgrEvent_0:
   \   000142   7417         MOV     A,#0x17
   \   000144   12....       LCALL   ?DEALLOC_XSTACK8
   \   000147   7F02         MOV     R7,#0x2
   \   000149   02....       LJMP    ?BANKED_LEAVE_XDATA
   2590          
   2591          /******************************************************************************
   2592           * @fn          ZDSecMgrEstablishKeyCfm
   2593           *
   2594           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2595           *
   2596           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2597           *
   2598           * @return      none
   2599           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2600          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2601          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2602            // send the NWK key
   2603            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2604            {
   2605              // update control for specified EXT address
   2606              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2607            }
   2608            else
   2609            {
   2610              // this should be done when receiving the NWK key
   2611              // if devState ==
   2612              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2613                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2614          
   2615              // if not in joining state -- this should trigger an event for an
   2616              // end point that requested SKKE
   2617              // if ( devState == DEV_END_DEVICE )
   2618             //       devState == DEV_ROUTER;
   2619          
   2620            }
   2621          }
   \   000000   02....       LJMP    ?BRET
   2622          
   2623          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2624          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2625          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2626            uint8  match;
   2627            uint8  lookup[Z_EXTADDR_LEN];
   2628          
   2629            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2630          
   2631            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2632            {
   2633              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2634            }
   2635          
   2636            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   7F01         MOV     R7,#0x1
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   2637          }
   2638          
   2639          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2640          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2641          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2642            uint16 ami;
   2643            uint8* key;
   2644          
   2645            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   705E         JNZ     ??ZDSecMgrTCDataLoad_0
   2646            {
   2647              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000031   E9           MOV     A,R1
   \   000032   7034         JNZ     ??ZDSecMgrTCDataLoad_1
   2648              {
   2649                // if preconfigured load key
   2650                if ( zgPreConfigKeys == TRUE )
   \   000034   90....       MOV     DPTR,#zgPreConfigKeys
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   702C         JNZ     ??ZDSecMgrTCDataLoad_1
   2651                {
   2652                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   AC82         MOV     R4,DPL
   \   000043   AD83         MOV     R5,DPH
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000053   E9           MOV     A,R1
   \   000054   6012         JZ      ??ZDSecMgrTCDataLoad_1
   2653                  {
   2654                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000056                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000056   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   000058   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00005A   85..82       MOV     DPL,?XSP + 0
   \   00005D   85..83       MOV     DPH,?XSP + 1
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FB           MOV     R3,A
   \   000065   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   2655                  }
   2656                }
   2657              }
   2658          
   2659              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000068   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00006B   7401         MOV     A,#0x1
   \   00006D   F0           MOVX    @DPTR,A
   2660            }
   2661          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00006E   7404         MOV     A,#0x4
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   7F02         MOV     R7,#0x2
   \   000075   02....       LJMP    ?BANKED_LEAVE_XDATA
   2662          
   2663          /******************************************************************************
   2664           * @fn          ZDSecMgrEstablishKeyInd
   2665           *
   2666           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2667           *
   2668           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2669           *
   2670           * @return      none
   2671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2672          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2673          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2674            ZDSecMgrDevice_t        device;
   2675            APSME_EstablishKeyRsp_t rsp;
   2676          
   2677          
   2678            // load Trust Center data if needed
   2679            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EE           MOV     A,R6
   \   00000F   2404         ADD     A,#0x4
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000018   AA..         MOV     R2,?V0 + 0
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2680          
   2681            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001E   EE           MOV     A,R6
   \   00001F   2402         ADD     A,#0x2
   \   000021   F8           MOV     R0,A
   \   000022   EF           MOV     A,R7
   \   000023   3400         ADDC    A,#0x0
   \   000025   F9           MOV     R1,A
   \   000026   88..         MOV     ?V0 + 2,R0
   \   000028   89..         MOV     ?V0 + 3,R1
   \   00002A                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   00002A   AA..         MOV     R2,?V0 + 0
   \   00002C   AB..         MOV     R3,?V0 + 1
   \   00002E   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   000031   E9           MOV     A,R1
   \   000032   601F         JZ      ??ZDSecMgrEstablishKeyInd_0
   2682            {
   2683              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2684              //OR
   2685              //!ZDSecMgrTCAuthenticated
   2686              //devtag.0604.critical
   2687                  //how is the parentAddr used here
   2688          
   2689              // initial SKKE from Trust Center via parent
   2690              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000034   7407         MOV     A,#0x7
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   A3           INC     DPTR
   \   00003C   F0           MOVX    @DPTR,A
   2691              device.parentAddr = ind->srcAddr;
   \   00003D   85..82       MOV     DPL,?V0 + 2
   \   000040   85..83       MOV     DPH,?V0 + 3
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F8           MOV     R0,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   740B         MOV     A,#0xb
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E8           MOV     A,R0
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   E9           MOV     A,R1
   \   000051   801F         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2692            }
   2693            else
   2694            {
   2695              // Trust Center direct or E2E SKKE
   2696              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000053   85..82       MOV     DPL,?V0 + 2
   \   000056   85..83       MOV     DPH,?V0 + 3
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F8           MOV     R0,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F9           MOV     R1,A
   \   00005E   7407         MOV     A,#0x7
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   E8           MOV     A,R0
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
   2697              device.parentAddr = INVALID_NODE_ADDR;
   \   000068   740B         MOV     A,#0xb
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   74FE         MOV     A,#-0x2
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   A3           INC     DPTR
   \   000071   04           INC     A
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000072   F0           MOVX    @DPTR,A
   2698            }
   2699          
   2700            device.extAddr = ind->initExtAddr;
   \   000073   7409         MOV     A,#0x9
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E5..         MOV     A,?V0 + 0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E5..         MOV     A,?V0 + 1
   \   00007E   F0           MOVX    @DPTR,A
   2701            //devtag.pro.security.0724.todo - verify usage
   2702            device.secure  = ind->nwkSecure;
   \   00007F   EE           MOV     A,R6
   \   000080   240E         ADD     A,#0xe
   \   000082   F8           MOV     R0,A
   \   000083   EF           MOV     A,R7
   \   000084   3400         ADDC    A,#0x0
   \   000086   F9           MOV     R1,A
   \   000087   88..         MOV     ?V0 + 0,R0
   \   000089   89..         MOV     ?V0 + 1,R1
   \   00008B   8882         MOV     DPL,R0
   \   00008D   F583         MOV     DPH,A
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   C0E0         PUSH    A
   \   000092   740D         MOV     A,#0xd
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   D0E0         POP     A
   \   000099   F0           MOVX    @DPTR,A
   2703          
   2704            // validate device for SKKE
   2705            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   00009A                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   00009A   7407         MOV     A,#0x7
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   AA82         MOV     R2,DPL
   \   0000A1   AB83         MOV     R3,DPH
   \   0000A3   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   0000A6   E9           MOV     A,R1
   \   0000A7   7009         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2706            {
   2707              rsp.accept = TRUE;
   \   0000A9   7404         MOV     A,#0x4
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   7401         MOV     A,#0x1
   \   0000B0   8006         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2708            }
   2709            else
   2710            {
   2711              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   0000B2   7404         MOV     A,#0x4
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   E4           CLR     A
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000B8   F0           MOVX    @DPTR,A
   2712            }
   2713          
   2714            rsp.dstAddr     = ind->srcAddr;
   \   0000B9   85..82       MOV     DPL,?V0 + 2
   \   0000BC   85..83       MOV     DPH,?V0 + 3
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   F8           MOV     R0,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F9           MOV     R1,A
   \   0000C4   85..82       MOV     DPL,?XSP + 0
   \   0000C7   85..83       MOV     DPH,?XSP + 1
   \   0000CA   E8           MOV     A,R0
   \   0000CB   F0           MOVX    @DPTR,A
   \   0000CC   A3           INC     DPTR
   \   0000CD   E9           MOV     A,R1
   \   0000CE   F0           MOVX    @DPTR,A
   2715            rsp.initExtAddr = &ind->initExtAddr[0];
   \   0000CF   EE           MOV     A,R6
   \   0000D0   2404         ADD     A,#0x4
   \   0000D2   F8           MOV     R0,A
   \   0000D3   EF           MOV     A,R7
   \   0000D4   3400         ADDC    A,#0x0
   \   0000D6   F9           MOV     R1,A
   \   0000D7   7402         MOV     A,#0x2
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   E8           MOV     A,R0
   \   0000DD   F0           MOVX    @DPTR,A
   \   0000DE   A3           INC     DPTR
   \   0000DF   E9           MOV     A,R1
   \   0000E0   F0           MOVX    @DPTR,A
   2716            //devtag.0604.todo - remove obsolete
   2717            rsp.apsSecure   = ind->apsSecure;
   \   0000E1   EE           MOV     A,R6
   \   0000E2   240D         ADD     A,#0xd
   \   0000E4   F582         MOV     DPL,A
   \   0000E6   EF           MOV     A,R7
   \   0000E7   3400         ADDC    A,#0x0
   \   0000E9   F583         MOV     DPH,A
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   C0E0         PUSH    A
   \   0000EE   7405         MOV     A,#0x5
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   D0E0         POP     A
   \   0000F5   F0           MOVX    @DPTR,A
   2718            rsp.nwkSecure   = ind->nwkSecure;
   \   0000F6   85..82       MOV     DPL,?V0 + 0
   \   0000F9   85..83       MOV     DPH,?V0 + 1
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   C0E0         PUSH    A
   \   0000FF   7406         MOV     A,#0x6
   \   000101   12....       LCALL   ?XSTACK_DISP0_8
   \   000104   D0E0         POP     A
   \   000106   F0           MOVX    @DPTR,A
   2719          
   2720            APSME_EstablishKeyRsp( &rsp );
   \   000107                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000107   85..82       MOV     DPL,?XSP + 0
   \   00010A   85..83       MOV     DPH,?XSP + 1
   \   00010D   AA82         MOV     R2,DPL
   \   00010F   AB83         MOV     R3,DPH
   \   000111   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   2721          }
   \   000114   7411         MOV     A,#0x11
   \   000116   12....       LCALL   ?DEALLOC_XSTACK8
   \   000119   7F04         MOV     R7,#0x4
   \   00011B   02....       LJMP    ?BANKED_LEAVE_XDATA
   2722          //devtag.pro.security
   2723          #if 0
   2724          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2725          {
   2726            ZDSecMgrDevice_t        device;
   2727            APSME_EstablishKeyRsp_t rsp;
   2728          
   2729          
   2730            device.extAddr = ind->initExtAddr;
   2731            device.secure  = ind->secure;
   2732          
   2733            if ( ind->secure == FALSE )
   2734            {
   2735              // SKKE from Trust Center is not secured between child and parent
   2736              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2737              device.parentAddr = ind->srcAddr;
   2738            }
   2739            else
   2740            {
   2741              // SKKE from initiator should be secured
   2742              device.nwkAddr    = ind->srcAddr;
   2743              device.parentAddr = INVALID_NODE_ADDR;
   2744            }
   2745          
   2746            rsp.dstAddr     = ind->srcAddr;
   2747            rsp.initExtAddr = &ind->initExtAddr[0];
   2748            rsp.secure      = ind->secure;
   2749          
   2750            // validate device for SKKE
   2751            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2752            {
   2753              rsp.accept = TRUE;
   2754            }
   2755            else
   2756            {
   2757              rsp.accept = FALSE;
   2758            }
   2759          
   2760            APSME_EstablishKeyRsp( &rsp );
   2761          }
   2762          #endif
   2763          
   2764          /******************************************************************************
   2765           * @fn          ZDSecMgrTransportKeyInd
   2766           *
   2767           * @brief       Process the ZDO_TransportKeyInd_t message.
   2768           *
   2769           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2770           *
   2771           * @return      none
   2772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2773          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2774          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2775            uint8 index;
   2776          
   2777            // load Trust Center data if needed
   2778            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2779          
   2780            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000014   EE           MOV     A,R6
   \   000015   2404         ADD     A,#0x4
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6078         JZ      ??ZDSecMgrTransportKeyInd_0
   2781            {
   2782              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2783              //ZDSecMgrTCMasterKey( ind );
   2784              {
   2785                if ( zgPreConfigKeys != TRUE )
   2786                {
   2787                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2788                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2789                }
   2790                else
   2791                {
   2792                  // error condition - reject key
   2793                }
   2794              }
   2795            }
   2796            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2797                      ( ind->keyType == 6                 ) ||
   2798                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000021   E0           MOVX    A,@DPTR
   \   000022   6401         XRL     A,#0x1
   \   000024   600A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   6406         XRL     A,#0x6
   \   000029   6005         JZ      ??ZDSecMgrTransportKeyInd_1
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   6405         XRL     A,#0x5
   \   00002E   7069         JNZ     ??ZDSecMgrTransportKeyInd_0
   2799            {
   2800              // check for dummy NWK key (all zeros)
   2801              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000030   7800         MOV     R0,#0x0
   \   000032   8001         SJMP    ??ZDSecMgrTransportKeyInd_2
   2802                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2803                    index++ );
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000034   08           INC     R0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000035   E8           MOV     A,R0
   \   000036   C3           CLR     C
   \   000037   9410         SUBB    A,#0x10
   \   000039   5015         JNC     ??ZDSecMgrTransportKeyInd_4
   \   00003B   88..         MOV     ?V0 + 0,R0
   \   00003D   EE           MOV     A,R6
   \   00003E   25..         ADD     A,?V0 + 0
   \   000040   F582         MOV     DPL,A
   \   000042   EF           MOV     A,R7
   \   000043   3400         ADDC    A,#0x0
   \   000045   F583         MOV     DPH,A
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   60E4         JZ      ??ZDSecMgrTransportKeyInd_3
   2804          
   2805              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000050   7410         MOV     A,#0x10
   \   000052   68           XRL     A,R0
   \   000053   7013         JNZ     ??ZDSecMgrTransportKeyInd_5
   2806              {
   2807                // load preconfigured key - once!!
   2808                if ( !_NIB.nwkKeyLoaded )
   \   000055   90....       MOV     DPTR,#_NIB + 61
   \   000058   E0           MOVX    A,@DPTR
   \   000059   703B         JNZ     ??ZDSecMgrTransportKeyInd_6
   2809                {
   2810                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   00005B                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   7A..         MOV     R2,#zgPreConfigKey & 0xff
   \   00005F   7B..         MOV     R3,#(zgPreConfigKey >> 8) & 0xff
   \   000061   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2811                  SSP_SwitchNwkKey( 0 );
   \   000064                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000064   7900         MOV     R1,#0x0
   \   000066   802B         SJMP    ??ZDSecMgrTransportKeyInd_7
   2812                }
   2813              }
   2814              else
   2815              {
   2816                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000068   EE           MOV     A,R6
   \   000069   2405         ADD     A,#0x5
   \   00006B   F8           MOV     R0,A
   \   00006C   EF           MOV     A,R7
   \   00006D   3400         ADDC    A,#0x0
   \   00006F   F9           MOV     R1,A
   \   000070   88..         MOV     ?V0 + 0,R0
   \   000072   89..         MOV     ?V0 + 1,R1
   \   000074                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000074   8882         MOV     DPL,R0
   \   000076   F583         MOV     DPH,A
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F9           MOV     R1,A
   \   00007A   EE           MOV     A,R6
   \   00007B   2406         ADD     A,#0x6
   \   00007D   FA           MOV     R2,A
   \   00007E   EF           MOV     A,R7
   \   00007F   3400         ADDC    A,#0x0
   \   000081   FB           MOV     R3,A
   \   000082   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2817                if ( !_NIB.nwkKeyLoaded )
   \   000085   90....       MOV     DPTR,#_NIB + 61
   \   000088   E0           MOVX    A,@DPTR
   \   000089   700B         JNZ     ??ZDSecMgrTransportKeyInd_6
   2818                {
   2819                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00008B                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00008B   85..82       MOV     DPL,?V0 + 0
   \   00008E   85..83       MOV     DPH,?V0 + 1
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F9           MOV     R1,A
   \                     ??ZDSecMgrTransportKeyInd_7:
   \   000093   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2820                }
   2821              }
   2822          
   2823              // handle next step in authentication process
   2824              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000096                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000096   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   2825            }
   2826            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2827            {
   2828              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2829              {
   2830                //ZDSecMgrTCLinkKey( ind );
   2831              }
   2832            }
   2833            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2834            {
   2835              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2836              {
   2837                uint16           ami;
   2838                AddrMgrEntry_t   entry;
   2839                ZDSecMgrEntry_t* entryZD;
   2840          
   2841                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2842          
   2843                if ( ind->initiator == TRUE )
   2844                {
   2845                  // get the ami data
   2846                  entry.user  = ADDRMGR_USER_SECURITY;
   2847                  entry.index = ami;
   2848                  AddrMgrEntryGet( &entry );
   2849          
   2850                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2851                  {
   2852                    APSME_EstablishKeyReq_t req;
   2853                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2854          
   2855                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2856          
   2857                    if ( entryZD == NULL )
   2858                    {
   2859                      // get new entry
   2860                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2861                      {
   2862                        // finish setting up entry
   2863                        entryZD->ami = ami;
   2864                      }
   2865                    }
   2866          
   2867                    req.respExtAddr = ind->srcExtAddr;
   2868                    req.method      = APSME_SKKE_METHOD;
   2869                    req.dstAddr     = entry.nwkAddr;
   2870                    //devtag.0604.todo - remove obsolete
   2871                    req.apsSecure   = FALSE;
   2872                    req.nwkSecure   = TRUE;
   2873                    APSME_EstablishKeyReq( &req );
   2874                  }
   2875                }
   2876                else
   2877                {
   2878                  if ( ami == INVALID_NODE_ADDR )
   2879                  {
   2880                    // store new EXT address
   2881                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2882                  }
   2883          
   2884                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2885                }
   2886          
   2887                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2888                //{
   2889                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2890                //}
   2891              }
   2892            }
   2893            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2894            {
   2895              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2896              {
   2897                uint16           ami;
   2898                ZDSecMgrEntry_t* entry;
   2899          
   2900                // get the address index
   2901                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2902                {
   2903                  // store new EXT address
   2904                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2905                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2906                }
   2907          
   2908                ZDSecMgrEntryLookupAMI( ami, &entry );
   2909          
   2910                if ( entry == NULL )
   2911                {
   2912                  // get new entry
   2913                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2914                  {
   2915                    // finish setting up entry
   2916                    entry->ami = ami;
   2917                  }
   2918                }
   2919          
   2920                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2921              }
   2922            }
   2923          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000099   7F02         MOV     R7,#0x2
   \   00009B   02....       LJMP    ?BANKED_LEAVE_XDATA
   2924          
   2925          /******************************************************************************
   2926           * @fn          ZDSecMgrUpdateDeviceInd
   2927           *
   2928           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2929           *
   2930           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2931           *
   2932           * @return      none
   2933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2934          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2935          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2936            ZDSecMgrDevice_t device;
   2937          
   2938          
   2939            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   2940            device.extAddr    = ind->devExtAddr;
   \   000023   EA           MOV     A,R2
   \   000024   2404         ADD     A,#0x4
   \   000026   F8           MOV     R0,A
   \   000027   EB           MOV     A,R3
   \   000028   3400         ADDC    A,#0x0
   \   00002A   F9           MOV     R1,A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E8           MOV     A,R0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   E9           MOV     A,R1
   \   000034   F0           MOVX    @DPTR,A
   2941            device.parentAddr = ind->srcAddr;
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F9           MOV     R1,A
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E8           MOV     A,R0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E9           MOV     A,R1
   \   000049   F0           MOVX    @DPTR,A
   2942          
   2943            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2944            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2945            //{
   2946            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2947            //  {
   2948            //    device.secure = TRUE;
   2949            //  }
   2950            //  else
   2951            //  {
   2952            //    device.secure = FALSE;
   2953            //  }
   2954          
   2955              // try to join this device
   2956              ZDSecMgrDeviceJoin( &device );
   \   00004A                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   AA82         MOV     R2,DPL
   \   000052   AB83         MOV     R3,DPH
   \   000054   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   2957            //}
   2958          }
   \   000057   740A         MOV     A,#0xa
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   D083         POP     DPH
   \   00005E   D082         POP     DPL
   \   000060   02....       LJMP    ?BRET
   2959          
   2960          /******************************************************************************
   2961           * @fn          ZDSecMgrRemoveDeviceInd
   2962           *
   2963           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2964           *
   2965           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2966           *
   2967           * @return      none
   2968           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2969          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2970          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2971            ZDSecMgrDevice_t device;
   2972          
   2973          
   2974            // only accept from Trust Center
   2975            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   49           ORL     A,R1
   \   000017   7042         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2976            {
   2977              // look up NWK address
   2978              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000019   EA           MOV     A,R2
   \   00001A   2404         ADD     A,#0x4
   \   00001C   FE           MOV     R6,A
   \   00001D   EB           MOV     A,R3
   \   00001E   3400         ADDC    A,#0x0
   \   000020   FF           MOV     R7,A
   \   000021                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   EE           MOV     A,R6
   \   00002C   FA           MOV     R2,A
   \   00002D   EF           MOV     A,R7
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   7024         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2979              {
   2980                device.parentAddr = NLME_GetShortAddr();
   \   000037                ; Setup parameters for call to function NLME_GetShortAddr
   \   000037   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EA           MOV     A,R2
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   EB           MOV     A,R3
   \   000043   F0           MOVX    @DPTR,A
   2981                device.extAddr    = ind->childExtAddr;
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   EE           MOV     A,R6
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   EF           MOV     A,R7
   \   00004D   F0           MOVX    @DPTR,A
   2982          
   2983                // remove device
   2984                ZDSecMgrDeviceRemove( &device );
   \   00004E                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2985              }
   2986            }
   2987          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   00005B   740A         MOV     A,#0xa
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   7F01         MOV     R7,#0x1
   \   000062   02....       LJMP    ?BANKED_LEAVE_XDATA
   2988          
   2989          /******************************************************************************
   2990           * @fn          ZDSecMgrRequestKeyInd
   2991           *
   2992           * @brief       Process the ZDO_RequestKeyInd_t message.
   2993           *
   2994           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2995           *
   2996           * @return      none
   2997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2998          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2999          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3000            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   EA           MOV     A,R2
   \   000005   2404         ADD     A,#0x4
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   6401         XRL     A,#0x1
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   3001            {
   3002            }
   3003            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   E0           MOVX    A,@DPTR
   \   000014   6402         XRL     A,#0x2
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   3004            {
   3005              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   3006            }
   3007            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   3008            {
   3009            }
   3010            //else ignore
   3011          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
   3012          
   3013          /******************************************************************************
   3014           * @fn          ZDSecMgrSwitchKeyInd
   3015           *
   3016           * @brief       Process the ZDO_SwitchKeyInd_t message.
   3017           *
   3018           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   3019           *
   3020           * @return      none
   3021           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3022          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   3023          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3024            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   3025          
   3026            // Save if nv
   3027            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   3028          }
   \   000014   D083         POP     DPH
   \   000016   D082         POP     DPL
   \   000018   02....       LJMP    ?BRET
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateInd
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateInd_t message.
   3034           *
   3035           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3040          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3041            APSME_AuthenticateReq_t req;
   3042            AddrMgrEntry_t          entry;
   3043          
   3044          
   3045            // update the address manager
   3046            //---------------------------------------------------------------------------
   3047            // note:
   3048            // required for EA processing, but ultimately EA logic could also use the
   3049            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3050            // table is supposed to have authentication states for neighbors
   3051            //---------------------------------------------------------------------------
   3052            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3053            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   EE           MOV     A,R6
   \   000017   2402         ADD     A,#0x2
   \   000019   F5..         MOV     ?V0 + 2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   F5..         MOV     ?V0 + 3,A
   \   000020   85..82       MOV     DPL,?V0 + 2
   \   000023   F583         MOV     DPH,A
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   7408         MOV     A,#0x8
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E8           MOV     A,R0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E9           MOV     A,R1
   \   000033   F0           MOVX    @DPTR,A
   3054            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \   000034   EE           MOV     A,R6
   \   000035   2404         ADD     A,#0x4
   \   000037   F5..         MOV     ?V0 + 0,A
   \   000039   EF           MOV     A,R7
   \   00003A   3400         ADDC    A,#0x0
   \   00003C   F5..         MOV     ?V0 + 1,A
   \   00003E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00003E   AC..         MOV     R4,?V0 + 0
   \   000040   FD           MOV     R5,A
   \   000041   740A         MOV     A,#0xa
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   AA82         MOV     R2,DPL
   \   000048   AB83         MOV     R3,DPH
   \   00004A   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3055          
   3056            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00004D                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00004D   7407         MOV     A,#0x7
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   AA82         MOV     R2,DPL
   \   000054   AB83         MOV     R3,DPH
   \   000056   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000059   E9           MOV     A,R1
   \   00005A   6401         XRL     A,#0x1
   \   00005C   7049         JNZ     ??ZDSecMgrAuthenticateInd_0
   3057            {
   3058              // set request fields
   3059              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00005E   85..82       MOV     DPL,?V0 + 2
   \   000061   85..83       MOV     DPH,?V0 + 3
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F8           MOV     R0,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   E8           MOV     A,R0
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   E9           MOV     A,R1
   \   000073   F0           MOVX    @DPTR,A
   3060              req.extAddr   = ind->aps.initExtAddr;
   \   000074   7402         MOV     A,#0x2
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E5..         MOV     A,?V0 + 0
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   E5..         MOV     A,?V0 + 1
   \   00007F   F0           MOVX    @DPTR,A
   3061              req.action    = APSME_EA_ACCEPT;
   \   000080   7406         MOV     A,#0x6
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   7401         MOV     A,#0x1
   \   000087   F0           MOVX    @DPTR,A
   3062              req.challenge = ind->aps.challenge;
   \   000088   EE           MOV     A,R6
   \   000089   240C         ADD     A,#0xc
   \   00008B   F8           MOV     R0,A
   \   00008C   EF           MOV     A,R7
   \   00008D   3400         ADDC    A,#0x0
   \   00008F   F9           MOV     R1,A
   \   000090   7404         MOV     A,#0x4
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   E8           MOV     A,R0
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   E9           MOV     A,R1
   \   000099   F0           MOVX    @DPTR,A
   3063          
   3064              // start EA processing
   3065              APSME_AuthenticateReq( &req );
   \   00009A                ; Setup parameters for call to function APSME_AuthenticateReq
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ??APSME_AuthenticateReq?relay
   3066            }
   3067          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   0000A7   7414         MOV     A,#0x14
   \   0000A9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AC   7F04         MOV     R7,#0x4
   \   0000AE   02....       LJMP    ?BANKED_LEAVE_XDATA
   3068          
   3069          /******************************************************************************
   3070           * @fn          ZDSecMgrAuthenticateCfm
   3071           *
   3072           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3073           *
   3074           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3075           *
   3076           * @return      none
   3077           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3078          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3079          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3080            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3081            {
   3082              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   00001C   90....       MOV     DPTR,#devState
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6405         XRL     A,#0x5
   \   000022   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3083              {
   3084                // inform ZDO that device has been authenticated
   3085                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000024                ; Setup parameters for call to function osal_set_event
   \   000024   7A80         MOV     R2,#-0x80
   \   000026   7B00         MOV     R3,#0x0
   \   000028   90....       MOV     DPTR,#ZDAppTaskID
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??osal_set_event?relay
   3086              }
   3087            }
   3088          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   000030   D083         POP     DPH
   \   000032   D082         POP     DPL
   \   000034   02....       LJMP    ?BRET
   3089          
   3090          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3091          /******************************************************************************
   3092           * @fn          ZDSecMgrUpdateNwkKey
   3093           *
   3094           * @brief       Load a new NWK key and trigger a network wide update.
   3095           *
   3096           * @param       key       - [in] new NWK key
   3097           * @param       keySeqNum - [in] new NWK key sequence number
   3098           *
   3099           * @return      ZStatus_t
   3100           */
   3101          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3102          {
   3103            ZStatus_t               status;
   3104            APSME_TransportKeyReq_t req;
   3105          
   3106            // initialize common elements of local variables
   3107            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3108              req.keyType   = KEY_TYPE_NWK_HIGH;
   3109            else
   3110              req.keyType   = KEY_TYPE_NWK;
   3111          
   3112            req.dstAddr   = dstAddr;
   3113            req.keySeqNum = keySeqNum;
   3114            req.key       = key;
   3115            req.extAddr   = NULL;
   3116            req.nwkSecure = TRUE;
   3117            req.apsSecure = TRUE;
   3118            req.tunnel    = NULL;
   3119          
   3120            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3121            {
   3122              ZDSecMgrEntry_t*        entry;
   3123              uint16                  index;
   3124              AddrMgrEntry_t          addrEntry;
   3125          
   3126              addrEntry.user = ADDRMGR_USER_SECURITY;
   3127          
   3128              status = ZFailure;
   3129          
   3130              // verify data is available
   3131              if ( ZDSecMgrEntries != NULL )
   3132              {
   3133                // find available entry
   3134                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3135                {
   3136                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3137                  {
   3138                    // return successful result
   3139                    entry = &ZDSecMgrEntries[index];
   3140          
   3141                    // get NWK address
   3142                    addrEntry.index = entry->ami;
   3143                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3144                    {
   3145                      req.dstAddr = addrEntry.nwkAddr;
   3146                      req.extAddr = addrEntry.extAddr;
   3147                      status = APSME_TransportKeyReq( &req );
   3148                    }
   3149                  }
   3150                }
   3151              }
   3152            }
   3153            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3154            {
   3155              status = APSME_TransportKeyReq( &req );
   3156            }
   3157          
   3158            SSP_UpdateNwkKey( key, keySeqNum );
   3159          
   3160            // Save if nv
   3161            ZDApp_NVUpdate();
   3162          
   3163            return status;
   3164          }
   3165          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3166          
   3167          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3168          /******************************************************************************
   3169           * @fn          ZDSecMgrSwitchNwkKey
   3170           *
   3171           * @brief       Causes the NWK key to switch via a network wide command.
   3172           *
   3173           * @param       keySeqNum - [in] new NWK key sequence number
   3174           *
   3175           * @return      ZStatus_t
   3176           */
   3177          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3178          {
   3179            ZStatus_t            status;
   3180            APSME_SwitchKeyReq_t req;
   3181          
   3182            // initialize common elements of local variables
   3183            req.dstAddr = dstAddr;
   3184            req.keySeqNum = keySeqNum;
   3185          
   3186            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3187            {
   3188              ZDSecMgrEntry_t*     entry;
   3189              uint16               index;
   3190              AddrMgrEntry_t       addrEntry;
   3191          
   3192              addrEntry.user = ADDRMGR_USER_SECURITY;
   3193          
   3194              status = ZFailure;
   3195          
   3196              // verify data is available
   3197              if ( ZDSecMgrEntries != NULL )
   3198              {
   3199                // find available entry
   3200                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3201                {
   3202                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3203                  {
   3204                    // return successful result
   3205                    entry = &ZDSecMgrEntries[index];
   3206          
   3207                    // get NWK address
   3208                    addrEntry.index = entry->ami;
   3209          
   3210                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3211                    {
   3212                      req.dstAddr = addrEntry.nwkAddr;
   3213                      status = APSME_SwitchKeyReq( &req );
   3214                    }
   3215                  }
   3216                }
   3217              }
   3218            }
   3219            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3220            {
   3221              status = APSME_SwitchKeyReq( &req );
   3222            }
   3223          
   3224            SSP_SwitchNwkKey( keySeqNum );
   3225          
   3226            // Save if nv
   3227            ZDApp_NVUpdate();
   3228          
   3229            return status;
   3230          }
   3231          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3232          
   3233          #if ( ZG_BUILD_JOINING_TYPE )
   3234          /******************************************************************************
   3235           * @fn          ZDSecMgrRequestAppKey
   3236           *
   3237           * @brief       Request an application key with partner.
   3238           *
   3239           * @param       partNwkAddr - [in] partner network address
   3240           *
   3241           * @return      ZStatus_t
   3242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3243          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3244          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV     A,#-0xc
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3245            ZStatus_t             status;
   3246            APSME_RequestKeyReq_t req;
   3247            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3248          
   3249          
   3250            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV     A,#0x4
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   AC82         MOV     R4,DPL
   \   000010   AD83         MOV     R5,DPH
   \   000012   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000015   E9           MOV     A,R1
   \   000016   6031         JZ      ??ZDSecMgrRequestAppKey_0
   3251            {
   3252              req.dstAddr = 0;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E4           CLR     A
   \   00001F   F0           MOVX    @DPTR,A
   3253              req.keyType = KEY_TYPE_APP_MASTER;
   \   000020   04           INC     A
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
   3254              req.partExtAddr = partExtAddr;
   \   000027   7404         MOV     A,#0x4
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   A882         MOV     R0,DPL
   \   00002E   A983         MOV     R1,DPH
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E8           MOV     A,R0
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E9           MOV     A,R1
   \   000039   F0           MOVX    @DPTR,A
   3255              status = APSME_RequestKeyReq( &req );
   \   00003A                ; Setup parameters for call to function APSME_RequestKeyReq
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   AA82         MOV     R2,DPL
   \   000042   AB83         MOV     R3,DPH
   \   000044   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   000047   8002         SJMP    ??ZDSecMgrRequestAppKey_1
   3256            }
   3257            else
   3258            {
   3259              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   000049   7901         MOV     R1,#0x1
   3260            }
   3261          
   3262            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   00004B   740C         MOV     A,#0xc
   \   00004D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000050   D083         POP     DPH
   \   000052   D082         POP     DPL
   \   000054   02....       LJMP    ?BRET
   3263          }
   3264          #endif // ( ZG_BUILD_JOINING_TYPE )
   3265          
   3266          #if ( ZG_BUILD_JOINING_TYPE )
   3267          /******************************************************************************
   3268           * @fn          ZDSecMgrSetupPartner
   3269           *
   3270           * @brief       Setup for application key partner.
   3271           *
   3272           * @param       partNwkAddr - [in] partner network address
   3273           *
   3274           * @return      ZStatus_t
   3275           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3276          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3277          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3278            AddrMgrEntry_t entry;
   3279            ZStatus_t      status;
   3280          
   3281            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   3282          
   3283            // update the address manager
   3284            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   3285            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC     A
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   EA           MOV     A,R2
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EB           MOV     A,R3
   \   000026   F0           MOVX    @DPTR,A
   3286            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000027                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   AA82         MOV     R2,DPL
   \   00002E   AB83         MOV     R3,DPH
   \   000030   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3287          
   3288            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000033                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   AA82         MOV     R2,DPL
   \   00003B   AB83         MOV     R3,DPH
   \   00003D   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000040   E9           MOV     A,R1
   \   000041   6401         XRL     A,#0x1
   \   000043   7038         JNZ     ??ZDSecMgrSetupPartner_0
   3289            {
   3290              status = ZSuccess;
   \   000045   75..00       MOV     ?V0 + 2,#0x0
   3291          
   3292              // check for address discovery
   3293              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000048   74FE         MOV     A,#-0x2
   \   00004A   65..         XRL     A,?V0 + 0
   \   00004C   7004         JNZ     ??ZDSecMgrSetupPartner_1
   \   00004E   74FF         MOV     A,#-0x1
   \   000050   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSetupPartner_1:
   \   000052   700F         JNZ     ??ZDSecMgrSetupPartner_2
   3294              {
   3295                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000054                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000054   7D00         MOV     R5,#0x0
   \   000056   7C00         MOV     R4,#0x0
   \   000058   7900         MOV     R1,#0x0
   \   00005A   EE           MOV     A,R6
   \   00005B   FA           MOV     R2,A
   \   00005C   EF           MOV     A,R7
   \   00005D   FB           MOV     R3,A
   \   00005E   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   000061   8017         SJMP    ??ZDSecMgrSetupPartner_3
   3296              }
   3297              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000063                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000063   EE           MOV     A,R6
   \   000064   FA           MOV     R2,A
   \   000065   EF           MOV     A,R7
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   00006A   E9           MOV     A,R1
   \   00006B   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3298              {
   3299                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00006D                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   7C00         MOV     R4,#0x0
   \   000071   7900         MOV     R1,#0x0
   \   000073   AA..         MOV     R2,?V0 + 0
   \   000075   AB..         MOV     R3,?V0 + 1
   \   000077   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \                     ??ZDSecMgrSetupPartner_3:
   \   00007A   E9           MOV     A,R1
   \   00007B   F5..         MOV     ?V0 + 2,A
   3300              }
   3301            }
   3302          
   3303            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   00007D   A9..         MOV     R1,?V0 + 2
   \   00007F   740D         MOV     A,#0xd
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   7F03         MOV     R7,#0x3
   \   000086   02....       LJMP    ?BANKED_LEAVE_XDATA
   3304          }
   3305          #endif // ( ZG_BUILD_JOINING_TYPE )
   3306          
   3307          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3308          /******************************************************************************
   3309           * @fn          ZDSecMgrAppKeyTypeSet
   3310           *
   3311           * @brief       Set application key type.
   3312           *
   3313           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3314           *                                                   KEY_TYPE_APP_LINK@3
   3315           *
   3316           * @return      ZStatus_t
   3317           */
   3318          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3319          {
   3320            if ( keyType == KEY_TYPE_APP_LINK )
   3321            {
   3322              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3323            }
   3324            else
   3325            {
   3326              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3327            }
   3328          
   3329            return ZSuccess;
   3330          }
   3331          #endif
   3332          
   3333          /******************************************************************************
   3334           * ZigBee Device Security Manager - Stub Implementations
   3335           */
   3336          /******************************************************************************
   3337           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3338           *
   3339           * @brief       Get MASTER key for specified EXT address.
   3340           *
   3341           * @param       extAddr - [in] EXT address
   3342           * @param       key     - [out] MASTER key
   3343           *
   3344           * @return      ZStatus_t
   3345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3346          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3347          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3348            ZStatus_t status;
   3349            uint16    ami;
   3350          
   3351          
   3352            // lookup entry for specified EXT address
   3353            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3354            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3355          
   3356            if ( status == ZSuccess )
   \   00001E   7014         JNZ     ??APSME_MasterKeyGet_0
   3357            {
   3358              ZDSecMgrMasterKeyLookup( ami, key );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   EE           MOV     A,R6
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   FD           MOV     R5,A
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FA           MOV     R2,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000032   8008         SJMP    ??APSME_MasterKeyGet_1
   3359            }
   3360            else
   3361            {
   3362              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
   3363            }
   3364          
   3365            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00003C   A9..         MOV     R1,?V0 + 0
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   \   000043   7F01         MOV     R7,#0x1
   \   000045   02....       LJMP    ?BANKED_LEAVE_XDATA
   3366          }
   3367          
   3368          /******************************************************************************
   3369           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3370           *
   3371           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3372           *
   3373           * @param       extAddr - [in] EXT address
   3374           * @param       data    - [in] APSME_LinkKeyData_t
   3375           *
   3376           * @return      ZStatus_t
   3377           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3378          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3379          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3380            ZStatus_t        status;
   3381            ZDSecMgrEntry_t* entry;
   3382          
   3383          
   3384            // lookup entry index for specified EXT address
   3385            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 3,A
   3386          
   3387            if ( status == ZSuccess )
   \   00001E   705E         JNZ     ??APSME_LinkKeySet_0
   3388            {
   3389              // setup the link key data reference
   3390              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   000020                ; Setup parameters for call to function osal_memcpy
   \   000020   8E..         MOV     ?V0 + 0,R6
   \   000022   8F..         MOV     ?V0 + 1,R7
   \   000024   75..00       MOV     ?V0 + 2,#0x0
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00002C   7C10         MOV     R4,#0x10
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   7403         MOV     A,#0x3
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E0           MOVX    A,@DPTR
   \   000036   2402         ADD     A,#0x2
   \   000038   FA           MOV     R2,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   3400         ADDC    A,#0x0
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??osal_memcpy?relay
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   3391          
   3392              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   000046   90....       MOV     DPTR,#__Constant_0
   \   000049   12....       LCALL   ?XLOAD_R2345
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2418         ADD     A,#0x18
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   3400         ADDC    A,#0x0
   \   00005A   F9           MOV     R1,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   8983         MOV     DPH,R1
   \   00005F   12....       LCALL   ?XSTORE_R2345
   3393              entry->lkd.apsmelkd.txFrmCntr = 0;
   \   000062   90....       MOV     DPTR,#__Constant_0
   \   000065   12....       LCALL   ?XLOAD_R2345
   \   000068   85..82       MOV     DPL,?XSP + 0
   \   00006B   85..83       MOV     DPH,?XSP + 1
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   2414         ADD     A,#0x14
   \   000071   F8           MOV     R0,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   3400         ADDC    A,#0x0
   \   000076   F9           MOV     R1,A
   \   000077   8882         MOV     DPL,R0
   \   000079   8983         MOV     DPH,R1
   \   00007B   12....       LCALL   ?XSTORE_R2345
   3394            }
   3395          
   3396            return status;
   \                     ??APSME_LinkKeySet_0:
   \   00007E   A9..         MOV     R1,?V0 + 3
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   7F04         MOV     R7,#0x4
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
   3397          }
   3398          
   3399          /******************************************************************************
   3400           * @fn          ZDSecMgrAuthenticationSet
   3401           *
   3402           * @brief       Mark the specific device as authenticated or not
   3403           *
   3404           * @param       extAddr - [in] EXT address
   3405           * @param       option  - [in] authenticated or not
   3406           *
   3407           * @return      ZStatus_t
   3408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3409          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3410          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3411            ZStatus_t        status;
   3412            ZDSecMgrEntry_t* entry;
   3413          
   3414          
   3415            // lookup entry index for specified EXT address
   3416            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   3417          
   3418            if ( status == ZSuccess )
   \   00001A   7019         JNZ     ??ZDSecMgrAuthenticationSet_0
   3419            {
   3420              entry->authenticateOption = option;
   \   00001C   EE           MOV     A,R6
   \   00001D   C0E0         PUSH    A
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   241C         ADD     A,#0x1c
   \   000028   FA           MOV     R2,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FB           MOV     R3,A
   \   00002E   8A82         MOV     DPL,R2
   \   000030   8B83         MOV     DPH,R3
   \   000032   D0E0         POP     A
   \   000034   F0           MOVX    @DPTR,A
   3421            }
   3422          
   3423            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000035   7402         MOV     A,#0x2
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003A   7F01         MOV     R7,#0x1
   \   00003C   02....       LJMP    ?BANKED_LEAVE_XDATA
   3424          }
   3425          
   3426          /******************************************************************************
   3427           * @fn          ZDSecMgrAuthenticationCheck
   3428           *
   3429           * @brief       Check if the specific device has been authenticated or not
   3430           *              For non-trust center device, always return true
   3431           *
   3432           * @param       shortAddr - [in] short address
   3433           *
   3434           * @return      TRUE @ authenticated with CBKE
   3435           *              FALSE @ not authenticated
   3436           */
   3437          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3438          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3439          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3440          #if defined (TC_LINKKEY_JOIN)
   3441          
   3442            ZDSecMgrEntry_t* entry;
   3443            uint8 extAddr[Z_EXTADDR_LEN];
   3444          
   3445            // If the local device is not the trust center, always return TRUE
   3446            if ( NLME_GetShortAddr() != TCshortAddr )
   3447            {
   3448              return TRUE;
   3449            }
   3450            // Otherwise, check the authentication option
   3451            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3452            {
   3453              // lookup entry index for specified EXT address
   3454              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3455              {
   3456                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3457                {
   3458                  return TRUE;
   3459                }
   3460                else
   3461                {
   3462                  return FALSE;
   3463                }
   3464              }
   3465            }
   3466            return FALSE;
   3467          
   3468          #else
   3469            (void)shortAddr;  // Intentionally unreferenced parameter
   3470            
   3471            // For non AMI/SE Profile, perform no check and always return true.
   3472            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3473          
   3474          #endif // TC_LINKKEY_JOIN
   3475          }
   3476          
   3477          
   3478          /******************************************************************************
   3479           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3480           *
   3481           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3482           *
   3483           * @param       extAddr - [in] EXT address
   3484           * @param       data    - [out] APSME_LinkKeyData_t
   3485           *
   3486           * @return      ZStatus_t
   3487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3488          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3489          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3490            ZStatus_t        status;
   3491            ZDSecMgrEntry_t* entry;
   3492          
   3493          
   3494            // lookup entry index for specified NWK address
   3495            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   3496          
   3497            if ( status == ZSuccess )
   \   00001C   7039         JNZ     ??APSME_LinkKeyDataGet_0
   3498            {
   3499              // setup the link key data reference
   3500              (*data) = &entry->lkd.apsmelkd;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   2412         ADD     A,#0x12
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   3400         ADDC    A,#0x0
   \   00002C   FB           MOV     R3,A
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   EA           MOV     A,R2
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   EB           MOV     A,R3
   \   000035   F0           MOVX    @DPTR,A
   3501              (*data)->key = entry->lkd.key;
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   2402         ADD     A,#0x2
   \   00003F   FA           MOV     R2,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   3400         ADDC    A,#0x0
   \   000044   FB           MOV     R3,A
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F583         MOV     DPH,A
   \   00004F   8882         MOV     DPL,R0
   \   000051   EA           MOV     A,R2
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   EB           MOV     A,R3
   \   000055   8007         SJMP    ??APSME_LinkKeyDataGet_1
   3502            }
   3503            else
   3504            {
   3505              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   00005E   F0           MOVX    @DPTR,A
   3506            }
   3507          
   3508            return status;
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   7F01         MOV     R7,#0x1
   \   000066   02....       LJMP    ?BANKED_LEAVE_XDATA
   3509          }
   3510          
   3511          /******************************************************************************
   3512           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3513           *
   3514           * @brief       Verify and process key transportation to child.
   3515           *
   3516           * @param       ind - [in] APSME_TransportKeyInd_t
   3517           *
   3518           * @return      uint8 - success(TRUE:FALSE)
   3519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3520          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3521          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3522            uint8 success;
   3523          
   3524            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3525          
   3526            // verify from Trust Center
   3527            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F8           MOV     R0,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
   \   000010   E8           MOV     A,R0
   \   000011   49           ORL     A,R1
   \   000012   702F         JNZ     ??APSME_KeyFwdToChild_0
   3528            {
   3529              success = TRUE;
   \   000014   0E           INC     R6
   3530          
   3531              // check for initial NWK key
   3532              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3533                   ( ind->keyType == 6                 ) ||
   3534                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000015   EA           MOV     A,R2
   \   000016   2402         ADD     A,#0x2
   \   000018   F582         MOV     DPL,A
   \   00001A   EB           MOV     A,R3
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6401         XRL     A,#0x1
   \   000022   600A         JZ      ??APSME_KeyFwdToChild_1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6406         XRL     A,#0x6
   \   000027   6005         JZ      ??APSME_KeyFwdToChild_1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6405         XRL     A,#0x5
   \   00002C   7015         JNZ     ??APSME_KeyFwdToChild_0
   3535              {
   3536                // set association status to authenticated
   3537                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00002E                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002E                ; Setup parameters for call to function AssocGetWithExt
   \   00002E   8A82         MOV     DPL,R2
   \   000030   8B83         MOV     DPH,R3
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??AssocGetWithExt?relay
   \   000040   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3538              }
   3539            }
   3540          
   3541            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000043   EE           MOV     A,R6
   \   000044   F9           MOV     R1,A
   \   000045   7F01         MOV     R7,#0x1
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
   3542          }
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrAddLinkKey
   3546           *
   3547           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3548           *              as authenticated in the authenticateOption. Note that this function
   3549           *              is hardwared to CBKE right now.
   3550           *
   3551           * @param       shortAddr - short address of the partner device
   3552           * @param       extAddr - extended address of the partner device
   3553           * @param       key - link key
   3554           *
   3555           * @return      ZStatus_t
   3556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3557          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3558          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   3559            uint16           ami;
   3560            ZDSecMgrEntry_t* entry;
   3561          
   3562            /* Store the device address in the addr manager */
   3563            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   E9           MOV     A,R1
   \   000033   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3564            {
   3565              /* Adding to Addr Manager fails */
   3566              return ZFailure;
   \   000035   7901         MOV     R1,#0x1
   \   000037   8060         SJMP    ??ZDSecMgrAddLinkKey_1
   3567            }
   3568          
   3569            /* Lookup entry using specified address index */
   3570            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000039                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   AC82         MOV     R4,DPL
   \   000041   AD83         MOV     R5,DPH
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E0           MOVX    A,@DPTR
   \   000049   FA           MOV     R2,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   3571          
   3572            // If no existing entry, create one
   3573            if ( entry == NULL )
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F9           MOV     R1,A
   \   00005B   E8           MOV     A,R0
   \   00005C   49           ORL     A,R1
   \   00005D   702D         JNZ     ??ZDSecMgrAddLinkKey_2
   3574            {
   3575              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00005F                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   AA82         MOV     R2,DPL
   \   000067   AB83         MOV     R3,DPH
   \   000069   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   00006C   E9           MOV     A,R1
   \   00006D   7034         JNZ     ??ZDSecMgrAddLinkKey_3
   3576              {
   3577                entry->ami = ami;
   \   00006F   7402         MOV     A,#0x2
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   85..82       MOV     DPL,?XSP + 0
   \   00007C   85..83       MOV     DPH,?XSP + 1
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   FA           MOV     R2,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F583         MOV     DPH,A
   \   000085   8A82         MOV     DPL,R2
   \   000087   E8           MOV     A,R0
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   E9           MOV     A,R1
   \   00008B   F0           MOVX    @DPTR,A
   3578              }
   3579              else
   3580              {
   3581                /* Security Manager full */
   3582                return ZBufferFull;
   3583              }
   3584            }
   3585            // Write the link key
   3586            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_2:
   \   00008C                ; Setup parameters for call to function APSME_LinkKeySet
   \   00008C   AC..         MOV     R4,?V0 + 0
   \   00008E   AD..         MOV     R5,?V0 + 1
   \   000090   EE           MOV     A,R6
   \   000091   FA           MOV     R2,A
   \   000092   EF           MOV     A,R7
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   ??APSME_LinkKeySet?relay
   3587          
   3588          #if defined (TC_LINKKEY_JOIN)
   3589            // Mark the device as authenticated.
   3590            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3591          #endif
   3592          
   3593          #if defined NV_RESTORE
   3594            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3595          #endif
   3596            
   3597            return ZSuccess;
   \   000097   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000099   7404         MOV     A,#0x4
   \   00009B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009E   7F04         MOV     R7,#0x4
   \   0000A0   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??ZDSecMgrAddLinkKey_3:
   \   0000A3   7911         MOV     R1,#0x11
   \   0000A5   80F2         SJMP    ??ZDSecMgrAddLinkKey_1
   3598          }
   3599          
   3600          #if defined ( NV_RESTORE )
   3601          /******************************************************************************
   3602           * @fn          ZDSecMgrInitNV
   3603           *
   3604           * @brief       Initialize the SecMgr entry data in NV.
   3605           *
   3606           * @param       none
   3607           *
   3608           * @return      uint8 - <osal_nv_item_init> return codes
   3609           */
   3610          uint8 ZDSecMgrInitNV(void)
   3611          {
   3612            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3613                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3614            if (rtrn != ZSUCCESS)  // If the item does not already exist.
   3615            {
   3616              nvDeviceListHdr_t hdr;
   3617              hdr.numRecs = 0;
   3618              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3619            }
   3620          
   3621            return rtrn;
   3622          }
   3623          #endif // NV_RESTORE
   3624          
   3625          #if defined ( NV_RESTORE )
   3626          /*********************************************************************
   3627           * @fn      ZDSecMgrWriteNV()
   3628           *
   3629           * @brief   Save off the link key list to NV
   3630           *
   3631           * @param   none
   3632           *
   3633           * @return  none
   3634           */
   3635          static void ZDSecMgrWriteNV( void )
   3636          {
   3637            uint16 i;
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            hdr.numRecs = 0;
   3641          
   3642            if (ZDSecMgrEntries != NULL)
   3643            {
   3644              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3645              {
   3646                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3647                {
   3648                  // Save off the record
   3649                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3650                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3651                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3652                  hdr.numRecs++;
   3653                }
   3654              }
   3655            }
   3656          
   3657            // Save off the header
   3658            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3659          }
   3660          #endif // NV_RESTORE
   3661          
   3662          #if defined ( NV_RESTORE )
   3663          /******************************************************************************
   3664           * @fn          ZDSecMgrRestoreFromNV
   3665           *
   3666           * @brief       Restore the SecMgr entry data from NV.
   3667           *
   3668           * @param       none
   3669           *
   3670           * @return      None.
   3671           */
   3672          static void ZDSecMgrRestoreFromNV( void )
   3673          {
   3674            nvDeviceListHdr_t hdr;
   3675          
   3676            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3677                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3678            {
   3679              uint8 x;
   3680          
   3681              for (x = 0; x < hdr.numRecs; x++)
   3682              {
   3683                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3684                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3685                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3686                {
   3687                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3688                }
   3689              }
   3690            }
   3691          }
   3692          #endif // NV_RESTORE
   3693          
   3694          /******************************************************************************
   3695           * @fn          ZDSecMgrAPSRemove
   3696           *
   3697           * @brief       Remove device from network.
   3698           *
   3699           * @param       nwkAddr - device's NWK address
   3700           * @param       extAddr - device's Extended address
   3701           * @param       parentAddr - parent's NWK address
   3702           *
   3703           * @return      ZStatus_t
   3704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3705          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3706          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   3707            ZDSecMgrDevice_t device;
   3708          
   3709            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3710                 ( extAddr == NULL )              ||
   3711                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000013   74FE         MOV     A,#-0x2
   \   000015   6A           XRL     A,R2
   \   000016   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   000018   74FF         MOV     A,#-0x1
   \   00001A   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   00001B   600E         JZ      ??ZDSecMgrAPSRemove_1
   \   00001D   EC           MOV     A,R4
   \   00001E   4D           ORL     A,R5
   \   00001F   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   000021   74FE         MOV     A,#-0x2
   \   000023   68           XRL     A,R0
   \   000024   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000026   74FF         MOV     A,#-0x1
   \   000028   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000029   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3712            {
   3713              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   802E         SJMP    ??ZDSecMgrAPSRemove_4
   3714            }
   3715          
   3716            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   F0           MOVX    @DPTR,A
   3717            device.extAddr = extAddr;
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
   3718            device.parentAddr = parentAddr;
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
   3719          
   3720            // remove device
   3721            ZDSecMgrDeviceRemove( &device );
   \   00004E                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3722          
   3723            return ( ZSuccess );
   \   00005B   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   00005D   740A         MOV     A,#0xa
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   D083         POP     DPH
   \   000064   D082         POP     DPL
   \   000066   02....       LJMP    ?BRET
   3724          }
   3725          
   3726          /******************************************************************************
   3727           * @fn          APSME_TCLinkKeyInit
   3728           *
   3729           * @brief       Initialize the NV table for preconfigured TC link key
   3730           *               
   3731           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3732           *              Trust Center Link Key is written to NV. A single tclk is used   
   3733           *              by all devices joining the network.
   3734           *              
   3735           * @param       none
   3736           *
   3737           * @return      none
   3738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3739          void APSME_TCLinkKeyInit(void)
   \                     APSME_TCLinkKeyInit:
   3740          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3741            uint8             i;
   3742            APSME_TCLinkKey_t tcLinkKey;
   3743            
   3744            // Initialize all NV items for preconfigured tclk with 
   3745            // extended address all zero, if not exist already.
   3746            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV     R4,#0x20
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   3747            for( i = 1; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00001D   8021         SJMP    ??APSME_TCLinkKeyInit_0
   3748            {
   3749              osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3750                                 sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_1:
   \   00001F                ; Setup parameters for call to function osal_nv_item_init
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   8582..       MOV     ?V0 + 0,DPL
   \   000028   8583..       MOV     ?V0 + 1,DPH
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   7C20         MOV     R4,#0x20
   \   000032   7D00         MOV     R5,#0x0
   \   000034   7A01         MOV     R2,#0x1
   \   000036   7B01         MOV     R3,#0x1
   \   000038   12....       LCALL   ??osal_nv_item_init?relay
   \   00003B   7402         MOV     A,#0x2
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   3751            }
   \                     ??APSME_TCLinkKeyInit_0:
   \   000040   7401         MOV     A,#0x1
   \   000042   60DB         JZ      ??APSME_TCLinkKeyInit_1
   3752            
   3753            // Initialize the default tclk
   3754            if( zgUseDefaultTCLK == TRUE )
   \   000044   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000047   E0           MOVX    A,@DPTR
   \   000048   6401         XRL     A,#0x1
   \   00004A   7036         JNZ     ??APSME_TCLinkKeyInit_2
   3755            {
   3756              osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00004C                ; Setup parameters for call to function osal_memset
   \   00004C   7C08         MOV     R4,#0x8
   \   00004E   7D00         MOV     R5,#0x0
   \   000050   79FF         MOV     R1,#-0x1
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   AA82         MOV     R2,DPL
   \   00005A   AB83         MOV     R3,DPH
   \   00005C   12....       LCALL   ??osal_memset?relay
   3757              osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   00005F                ; Setup parameters for call to function osal_memcpy
   \   00005F   75....       MOV     ?V0 + 0,#defaultTCLinkKey & 0xff
   \   000062   75....       MOV     ?V0 + 1,#(defaultTCLinkKey >> 8) & 0xff
   \   000065   75..80       MOV     ?V0 + 2,#-0x80
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006D   7C10         MOV     R4,#0x10
   \   00006F   7D00         MOV     R5,#0x0
   \   000071   740B         MOV     A,#0xb
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   AA82         MOV     R2,DPL
   \   000078   AB83         MOV     R3,DPH
   \   00007A   12....       LCALL   ??osal_memcpy?relay
   \   00007D   7403         MOV     A,#0x3
   \   00007F   12....       LCALL   ?DEALLOC_XSTACK8
   3758              
   3759              // If the item doesn't exist in NV memory, create and initialize
   3760              // it with the default value passed in.
   3761              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000082                ; Setup parameters for call to function osal_nv_item_init
   3762            }
   3763            else
   3764            {
   3765              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_2:
   \   000082                ; Setup parameters for call to function osal_nv_item_init
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   8582..       MOV     ?V0 + 0,DPL
   \   00008B   8583..       MOV     ?V0 + 1,DPH
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000093   7C20         MOV     R4,#0x20
   \   000095   7D00         MOV     R5,#0x0
   \   000097   7A01         MOV     R2,#0x1
   \   000099   7B01         MOV     R3,#0x1
   \   00009B   12....       LCALL   ??osal_nv_item_init?relay
   \   00009E   7402         MOV     A,#0x2
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   3766            }
   3767          }
   \   0000A3   7420         MOV     A,#0x20
   \   0000A5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A8   7F03         MOV     R7,#0x3
   \   0000AA   02....       LJMP    ?BANKED_LEAVE_XDATA
   3768          
   3769          /******************************************************************************
   3770           * @fn          APSME_TCLinkKeySync
   3771           *
   3772           * @brief       Sync Trust Center LINK key data.
   3773           *
   3774           * @param       srcAddr - [in] srcAddr
   3775           * @param       si      - [in, out] SSP_Info_t
   3776           *
   3777           * @return      ZStatus_t
   3778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3779          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3780          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3781            ZStatus_t          status = ZSecNoKey;
   \   000012   75..A1       MOV     ?V0 + 4,#-0x5f
   3782            uint8              i;
   3783            APSME_TCLinkKey_t  tcLinkKey;       
   3784            
   3785            // Look up the IEEE address of the trust center if it's available
   3786            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000015   EE           MOV     A,R6
   \   000016   2406         ADD     A,#0x6
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   EF           MOV     A,R7
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   F5..         MOV     ?V0 + 1,A
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001F   AA..         MOV     R2,?V0 + 0
   \   000021   FB           MOV     R3,A
   \   000022   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000025   E9           MOV     A,R1
   \   000026   700B         JNZ     ??APSME_TCLinkKeySync_0
   3787            {
   3788              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000028                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000028   AC..         MOV     R4,?V0 + 0
   \   00002A   AD..         MOV     R5,?V0 + 1
   \   00002C   AA..         MOV     R2,?V0 + 2
   \   00002E   AB..         MOV     R3,?V0 + 3
   \   000030   12....       LCALL   ??APSME_LookupExtAddr?relay
   3789            }
   3790            
   3791            // Look up the TC link key associated with the device
   3792            // or the default TC link key (extAddr is all FFs), whichever is found
   3793            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_0:
   \   000033   E4           CLR     A
   \   000034   8002         SJMP    ??APSME_TCLinkKeySync_1
   \                     ??APSME_TCLinkKeySync_2:
   \   000036   7401         MOV     A,#0x1
   \                     ??APSME_TCLinkKeySync_1:
   \   000038   6003         JZ      $+5
   \   00003A   02....       LJMP    ??APSME_TCLinkKeySync_3 & 0xFFFF
   3794            {
   3795              // Read entry i of the TC link key table from NV
   3796              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3797                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00003D                ; Setup parameters for call to function osal_nv_read
   \   00003D   85..82       MOV     DPL,?XSP + 0
   \   000040   85..83       MOV     DPH,?XSP + 1
   \   000043   8582..       MOV     ?V0 + 2,DPL
   \   000046   8583..       MOV     ?V0 + 3,DPH
   \   000049   78..         MOV     R0,#?V0 + 2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   75..20       MOV     ?V0 + 2,#0x20
   \   000051   75..00       MOV     ?V0 + 3,#0x0
   \   000054   78..         MOV     R0,#?V0 + 2
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000059   7C00         MOV     R4,#0x0
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   7A01         MOV     R2,#0x1
   \   00005F   7B01         MOV     R3,#0x1
   \   000061   12....       LCALL   ??osal_nv_read?relay
   \   000064   7404         MOV     A,#0x4
   \   000066   12....       LCALL   ?DEALLOC_XSTACK8
   3798              
   3799              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3800                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000069                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   AC82         MOV     R4,DPL
   \   000071   AD83         MOV     R5,DPH
   \   000073   AA..         MOV     R2,?V0 + 0
   \   000075   AB..         MOV     R3,?V0 + 1
   \   000077   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   00007A   E9           MOV     A,R1
   \   00007B   7010         JNZ     ??APSME_TCLinkKeySync_4
   \   00007D                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00007D   85..82       MOV     DPL,?XSP + 0
   \   000080   85..83       MOV     DPH,?XSP + 1
   \   000083   AA82         MOV     R2,DPL
   \   000085   AB83         MOV     R3,DPH
   \   000087   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   00008A   E9           MOV     A,R1
   \   00008B   60A9         JZ      ??APSME_TCLinkKeySync_2
   3801              {
   3802                // verify that the incoming frame counter is valid
   3803                if ( si->frmCntr >= tcLinkKey.rxFrmCntr )
   \                     ??APSME_TCLinkKeySync_4:
   \   00008D   EE           MOV     A,R6
   \   00008E   2412         ADD     A,#0x12
   \   000090   F5..         MOV     ?V0 + 0,A
   \   000092   EF           MOV     A,R7
   \   000093   3400         ADDC    A,#0x0
   \   000095   F5..         MOV     ?V0 + 1,A
   \   000097   85..82       MOV     DPL,?V0 + 0
   \   00009A   F583         MOV     DPH,A
   \   00009C   C082         PUSH    DPL
   \   00009E   C083         PUSH    DPH
   \   0000A0   741C         MOV     A,#0x1c
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   78..         MOV     R0,#?V0 + 4
   \   0000A7   12....       LCALL   ?L_MOV_X
   \   0000AA   D083         POP     DPH
   \   0000AC   D082         POP     DPL
   \   0000AE   78..         MOV     R0,#?V0 + 4
   \   0000B0   12....       LCALL   ?UL_GT_X
   \   0000B3   407E         JC      ??APSME_TCLinkKeySync_5
   3804                {
   3805                  // set the key to use
   3806                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN );
   \   0000B5                ; Setup parameters for call to function osal_memcpy
   \   0000B5   7408         MOV     A,#0x8
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   A982         MOV     R1,DPL
   \   0000BC   AA83         MOV     R2,DPH
   \   0000BE   89..         MOV     ?V0 + 4,R1
   \   0000C0   8A..         MOV     ?V0 + 5,R2
   \   0000C2   75..00       MOV     ?V0 + 6,#0x0
   \   0000C5   78..         MOV     R0,#?V0 + 4
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000CA   7C10         MOV     R4,#0x10
   \   0000CC   7D00         MOV     R5,#0x0
   \   0000CE   EE           MOV     A,R6
   \   0000CF   240F         ADD     A,#0xf
   \   0000D1   F582         MOV     DPL,A
   \   0000D3   EF           MOV     A,R7
   \   0000D4   3400         ADDC    A,#0x0
   \   0000D6   F583         MOV     DPH,A
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   FA           MOV     R2,A
   \   0000DA   A3           INC     DPTR
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   FB           MOV     R3,A
   \   0000DD   12....       LCALL   ??osal_memcpy?relay
   \   0000E0   7403         MOV     A,#0x3
   \   0000E2   12....       LCALL   ?DEALLOC_XSTACK8
   3807                  
   3808                  // update the rx frame counter
   3809                  tcLinkKey.rxFrmCntr = si->frmCntr + 1;
   \   0000E5   85..82       MOV     DPL,?V0 + 0
   \   0000E8   85..83       MOV     DPH,?V0 + 1
   \   0000EB   78..         MOV     R0,#?V0 + 0
   \   0000ED   12....       LCALL   ?L_MOV_X
   \   0000F0   90....       MOV     DPTR,#__Constant_1
   \   0000F3   78..         MOV     R0,#?V0 + 0
   \   0000F5   12....       LCALL   ?L_ADD_X
   \   0000F8   741C         MOV     A,#0x1c
   \   0000FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FD   78..         MOV     R0,#?V0 + 0
   \   0000FF   12....       LCALL   ?L_MOV_TO_X
   3810                  
   3811                  // Write the tc link key back to the NV
   3812                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3813                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000102                ; Setup parameters for call to function osal_nv_write
   \   000102   85..82       MOV     DPL,?XSP + 0
   \   000105   85..83       MOV     DPH,?XSP + 1
   \   000108   8582..       MOV     ?V0 + 0,DPL
   \   00010B   8583..       MOV     ?V0 + 1,DPH
   \   00010E   78..         MOV     R0,#?V0 + 0
   \   000110   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000113   75..20       MOV     ?V0 + 0,#0x20
   \   000116   75..00       MOV     ?V0 + 1,#0x0
   \   000119   78..         MOV     R0,#?V0 + 0
   \   00011B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011E   7C00         MOV     R4,#0x0
   \   000120   7D00         MOV     R5,#0x0
   \   000122   7A01         MOV     R2,#0x1
   \   000124   7B01         MOV     R3,#0x1
   \   000126   12....       LCALL   ??osal_nv_write?relay
   \   000129   7404         MOV     A,#0x4
   \   00012B   12....       LCALL   ?DEALLOC_XSTACK8
   3814                  
   3815                  status = ZSuccess;
   \   00012E   75..00       MOV     ?V0 + 4,#0x0
   \   000131   8003         SJMP    ??APSME_TCLinkKeySync_3
   3816                  
   3817                }
   3818                else
   3819                {
   3820                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_5:
   \   000133   75..A2       MOV     ?V0 + 4,#-0x5e
   3821                }
   3822                
   3823                return status;
   \                     ??APSME_TCLinkKeySync_3:
   \   000136   A9..         MOV     R1,?V0 + 4
   \   000138   7420         MOV     A,#0x20
   \   00013A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013D   7F08         MOV     R7,#0x8
   \   00013F   02....       LJMP    ?BANKED_LEAVE_XDATA
   3824              }
   3825            }
   3826            
   3827            
   3828            return status;
   3829          }
   3830          
   3831          /******************************************************************************
   3832           * @fn          APSME_TCLinkKeyLoad
   3833           *
   3834           * @brief       Load Trust Center LINK key data.
   3835           *
   3836           * @param       dstAddr - [in] dstAddr
   3837           * @param       si      - [in, out] SSP_Info_t
   3838           *
   3839           * @return      ZStatus_t
   3840           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3841          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3842          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   3843            uint8              i;
   3844            APSME_TCLinkKey_t  tcLinkKey;
   3845            AddrMgrEntry_t     addrEntry;  
   3846            
   3847            // Look up the ami of the srcAddr if available
   3848            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   E4           CLR     A
   \   000015   F0           MOVX    @DPTR,A
   3849            addrEntry.nwkAddr = dstAddr;
   \   000016   04           INC     A
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   EA           MOV     A,R2
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   EB           MOV     A,R3
   \   00001E   F0           MOVX    @DPTR,A
   3850          
   3851            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \   00001F   EC           MOV     A,R4
   \   000020   2406         ADD     A,#0x6
   \   000022   FE           MOV     R6,A
   \   000023   ED           MOV     A,R5
   \   000024   3400         ADDC    A,#0x0
   \   000026   FF           MOV     R7,A
   \   000027                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000027   EE           MOV     A,R6
   \   000028   FC           MOV     R4,A
   \   000029   EF           MOV     A,R7
   \   00002A   FD           MOV     R5,A
   \   00002B   12....       LCALL   ??APSME_LookupExtAddr?relay
   3852          
   3853            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   00002E                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000035   E9           MOV     A,R1
   \   000036   6401         XRL     A,#0x1
   \   000038   6003         JZ      $+5
   \   00003A   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3854            {
   3855              // Look up the TC link key associated with the device
   3856              // or the master TC link key (ami = 0xFFFF), whichever is found
   3857              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00003D   E4           CLR     A
   \   00003E   8002         SJMP    ??APSME_TCLinkKeyLoad_1
   \                     ??APSME_TCLinkKeyLoad_2:
   \   000040   7401         MOV     A,#0x1
   \                     ??APSME_TCLinkKeyLoad_1:
   \   000042   6003         JZ      $+5
   \   000044   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3858              {
   3859                // Read entry i of the TC link key table from NV
   3860                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3861                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000047                ; Setup parameters for call to function osal_nv_read
   \   000047   740D         MOV     A,#0xd
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   8582..       MOV     ?V0 + 2,DPL
   \   00004F   8583..       MOV     ?V0 + 3,DPH
   \   000052   78..         MOV     R0,#?V0 + 2
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   75..20       MOV     ?V0 + 2,#0x20
   \   00005A   75..00       MOV     ?V0 + 3,#0x0
   \   00005D   78..         MOV     R0,#?V0 + 2
   \   00005F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000062   7C00         MOV     R4,#0x0
   \   000064   7D00         MOV     R5,#0x0
   \   000066   7A01         MOV     R2,#0x1
   \   000068   7B01         MOV     R3,#0x1
   \   00006A   12....       LCALL   ??osal_nv_read?relay
   \   00006D   7404         MOV     A,#0x4
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
   3862                
   3863                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3864                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000072                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000072   740D         MOV     A,#0xd
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   AC82         MOV     R4,DPL
   \   000079   AD83         MOV     R5,DPH
   \   00007B   EE           MOV     A,R6
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   FB           MOV     R3,A
   \   00007F   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000082   E9           MOV     A,R1
   \   000083   700F         JNZ     ??APSME_TCLinkKeyLoad_3
   \   000085                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000085   740D         MOV     A,#0xd
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   AA82         MOV     R2,DPL
   \   00008C   AB83         MOV     R3,DPH
   \   00008E   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   000091   E9           MOV     A,R1
   \   000092   60AC         JZ      ??APSME_TCLinkKeyLoad_2
   3865                {
   3866                  // set the key to use
   3867                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN);  
   \                     ??APSME_TCLinkKeyLoad_3:
   \   000094                ; Setup parameters for call to function osal_memcpy
   \   000094   7415         MOV     A,#0x15
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   A982         MOV     R1,DPL
   \   00009B   AA83         MOV     R2,DPH
   \   00009D   89..         MOV     ?V0 + 4,R1
   \   00009F   8A..         MOV     ?V0 + 5,R2
   \   0000A1   75..00       MOV     ?V0 + 6,#0x0
   \   0000A4   78..         MOV     R0,#?V0 + 4
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000A9   7C10         MOV     R4,#0x10
   \   0000AB   7D00         MOV     R5,#0x0
   \   0000AD   E5..         MOV     A,?V0 + 0
   \   0000AF   240F         ADD     A,#0xf
   \   0000B1   F582         MOV     DPL,A
   \   0000B3   E5..         MOV     A,?V0 + 1
   \   0000B5   3400         ADDC    A,#0x0
   \   0000B7   F583         MOV     DPH,A
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   FA           MOV     R2,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   FB           MOV     R3,A
   \   0000BE   12....       LCALL   ??osal_memcpy?relay
   \   0000C1   7403         MOV     A,#0x3
   \   0000C3   12....       LCALL   ?DEALLOC_XSTACK8
   3868                  
   3869                  // update link key related fields
   3870                  si->keyID   = SEC_KEYID_LINK;
   \   0000C6   E5..         MOV     A,?V0 + 0
   \   0000C8   240E         ADD     A,#0xe
   \   0000CA   F582         MOV     DPL,A
   \   0000CC   E5..         MOV     A,?V0 + 1
   \   0000CE   3400         ADDC    A,#0x0
   \   0000D0   F583         MOV     DPH,A
   \   0000D2   E4           CLR     A
   \   0000D3   F0           MOVX    @DPTR,A
   3871                  si->frmCntr = tcLinkKey.txFrmCntr;
   \   0000D4   7425         MOV     A,#0x25
   \   0000D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D9   12....       LCALL   ?XLOAD_R2345
   \   0000DC   E5..         MOV     A,?V0 + 0
   \   0000DE   2412         ADD     A,#0x12
   \   0000E0   F582         MOV     DPL,A
   \   0000E2   E5..         MOV     A,?V0 + 1
   \   0000E4   3400         ADDC    A,#0x0
   \   0000E6   F583         MOV     DPH,A
   \   0000E8   12....       LCALL   ?XSTORE_R2345
   3872                
   3873                  // update outgoing frame counter
   3874                  tcLinkKey.txFrmCntr++;
   \   0000EB   90....       MOV     DPTR,#__Constant_1
   \   0000EE   78..         MOV     R0,#?V0 + 0
   \   0000F0   12....       LCALL   ?L_MOV_X
   \   0000F3   7425         MOV     A,#0x25
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   78..         MOV     R0,#?V0 + 0
   \   0000FA   12....       LCALL   ?L_ADD_TO_X
   3875                  
   3876                  // Write the tc link key back to the NV
   3877                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3878                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000FD                ; Setup parameters for call to function osal_nv_write
   \   0000FD   740D         MOV     A,#0xd
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   8582..       MOV     ?V0 + 0,DPL
   \   000105   8583..       MOV     ?V0 + 1,DPH
   \   000108   78..         MOV     R0,#?V0 + 0
   \   00010A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010D   75..20       MOV     ?V0 + 0,#0x20
   \   000110   75..00       MOV     ?V0 + 1,#0x0
   \   000113   78..         MOV     R0,#?V0 + 0
   \   000115   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000118   7C00         MOV     R4,#0x0
   \   00011A   7D00         MOV     R5,#0x0
   \   00011C   7A01         MOV     R2,#0x1
   \   00011E   7B01         MOV     R3,#0x1
   \   000120   12....       LCALL   ??osal_nv_write?relay
   \   000123   7404         MOV     A,#0x4
   \   000125   12....       LCALL   ?DEALLOC_XSTACK8
   3879                  
   3880                  return ZSuccess;
   \   000128   7900         MOV     R1,#0x0
   \   00012A   8021         SJMP    ??APSME_TCLinkKeyLoad_4
   3881                }
   3882              }
   3883            }
   3884              
   3885            // If no TC link key found, remove the device from the address manager
   3886            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00012C                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00012C   85..82       MOV     DPL,?XSP + 0
   \   00012F   85..83       MOV     DPH,?XSP + 1
   \   000132   AA82         MOV     R2,DPL
   \   000134   AB83         MOV     R3,DPH
   \   000136   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000139   E9           MOV     A,R1
   \   00013A   6401         XRL     A,#0x1
   \   00013C   700D         JNZ     ??APSME_TCLinkKeyLoad_5
   3887            {
   3888              AddrMgrEntryRelease( &addrEntry );
   \   00013E                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00013E   85..82       MOV     DPL,?XSP + 0
   \   000141   85..83       MOV     DPH,?XSP + 1
   \   000144   AA82         MOV     R2,DPL
   \   000146   AB83         MOV     R3,DPH
   \   000148   12....       LCALL   ??AddrMgrEntryRelease?relay
   3889            }
   3890          
   3891            return ZSecNoKey;
   \                     ??APSME_TCLinkKeyLoad_5:
   \   00014B   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_4:
   \   00014D   742D         MOV     A,#0x2d
   \   00014F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000152   7F07         MOV     R7,#0x7
   \   000154   02....       LJMP    ?BANKED_LEAVE_XDATA
   3892          }
   3893          
   3894          /******************************************************************************
   3895           * @fn          APSME_IsDefaultTCLK
   3896           *
   3897           * @brief       Return true or false based on the extended address.  If the 
   3898           *              input ext address is all FFs, it means the trust center link
   3899           *              assoiciated with the address is the default trust center link key
   3900           *
   3901           * @param       extAddr - [in] extended address
   3902           *
   3903           * @return      uint8 TRUE/FALSE
   3904           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3905          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   3906          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3907            uint8 i = 0;
   \   000004   7C00         MOV     R4,#0x0
   3908            
   3909            if( extAddr == NULL )
   \   000006   EA           MOV     A,R2
   \   000007   4B           ORL     A,R3
   \   000008   7019         JNZ     ??APSME_IsDefaultTCLK_0
   3910            {
   3911              return FALSE;
   \                     ??APSME_IsDefaultTCLK_1:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   801E         SJMP    ??APSME_IsDefaultTCLK_2
   3912            }
   3913            
   3914            while( i++ < Z_EXTADDR_LEN )
   3915            {
   3916              if( *extAddr++ != 0xFF )
   \                     ??APSME_IsDefaultTCLK_3:
   \   00000E   EA           MOV     A,R2
   \   00000F   F8           MOV     R0,A
   \   000010   EB           MOV     A,R3
   \   000011   F9           MOV     R1,A
   \   000012   8882         MOV     DPL,R0
   \   000014   8983         MOV     DPH,R1
   \   000016   A3           INC     DPTR
   \   000017   AA82         MOV     R2,DPL
   \   000019   AB83         MOV     R3,DPH
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F4           CPL     A
   \   000021   70E7         JNZ     ??APSME_IsDefaultTCLK_1
   3917              {
   3918                return FALSE;
   3919              }
   3920            }
   \                     ??APSME_IsDefaultTCLK_0:
   \   000023   EC           MOV     A,R4
   \   000024   0C           INC     R4
   \   000025   C3           CLR     C
   \   000026   9408         SUBB    A,#0x8
   \   000028   40E4         JC      ??APSME_IsDefaultTCLK_3
   3921            
   3922            return TRUE;
   \   00002A   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_2:
   \   00002C   D083         POP     DPH
   \   00002E   D082         POP     DPL
   \   000030   02....       LJMP    ?BRET
   3923          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyDataGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK
   3924          
   3925          
   3926          /******************************************************************************
   3927          ******************************************************************************/
   3928          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_IsDefaultTCLK                2      0     60
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyDataGet               0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     APSME_LinkKeySet                   0      0     33
       -> ZDSecMgrEntryLookupExt        0      0     28
       -> osal_memcpy                   0      0     34
     APSME_MasterKeyGet                 0      0     11
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrMasterKeyLookup       0      0     22
     APSME_SKA_TimerExpired             0      0      0
     APSME_TCLinkKeyInit                0      0     46
       -> osal_memset                   0      0     86
       -> osal_nv_item_init             0      0     90
       -> osal_memset                   0      0     86
       -> osal_memcpy                   0      0     92
       -> osal_nv_item_init             0      0     90
       -> osal_nv_item_init             0      0     90
     APSME_TCLinkKeyLoad                0      0     64
       -> APSME_LookupExtAddr           0      0    120
       -> AddrMgrExtAddrValid           0      0    120
       -> osal_nv_read                  0      0    128
       -> AddrMgrExtAddrEqual           0      0    120
       -> APSME_IsDefaultTCLK           0      0    120
       -> osal_memcpy                   0      0    126
       -> osal_nv_write                 0      0    128
       -> AddrMgrEntryLookupNwk         0      0    120
       -> AddrMgrEntryRelease           0      0    120
     APSME_TCLinkKeySync                2      0     52
       -> AddrMgrExtAddrValid           0      0     96
       -> APSME_LookupExtAddr           0      0     96
       -> osal_nv_read                  0      0    104
       -> AddrMgrExtAddrEqual           0      0     96
       -> APSME_IsDefaultTCLK           0      0     96
       -> osal_memcpy                   0      0    102
       -> osal_nv_write                 0      0    104
     ZDSecMgrAPSRemove                  2      0     12
       -> ZDSecMgrDeviceRemove          4      0     20
     ZDSecMgrAddLinkKey                 0      0     20
       -> ZDSecMgrAddrStore             0      0     36
       -> ZDSecMgrEntryLookupAMI        0      0     32
       -> ZDSecMgrEntryNew              0      0     32
       -> APSME_LinkKeySet              0      0     32
     ZDSecMgrAddrMgrUpdate              0      0     35
       -> AddrMgrEntryGet               0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAddrStore                  0      0     40
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAppKeyGet                  1      0     68
       -> SSP_GetTrueRand               0      0     18
     ZDSecMgrAppKeyReq                  0      0     59
       -> APSME_LookupNwkAddr           0      0    102
       -> APSME_LookupExtAddr           0      0    102
       -> ZDSecMgrAppKeyGet             0      0    118
       -> APSME_TransportKeyReq         0      0    102
       -> APSME_TransportKeyReq         0      0    102
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               0      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     10
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            2      0      0
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateInd            0      0     32
       -> AddrMgrExtAddrSet             0      0     64
       -> AddrMgrEntryUpdate            0      0     64
       -> APSME_AuthenticateReq         0      0     64
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     ZDSecMgrConfig                     2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     26
       -> ZDSecMgrCtrlSet               0      0     28
     ZDSecMgrCtrlInit                   2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrCtrlLookup                 0      0     23
     ZDSecMgrCtrlRelease                2      0      9
     ZDSecMgrCtrlReset                  0      0     14
       -> ZDSecMgrCtrlLookup            0      0     24
       -> ZDSecMgrCtrlSet               0      0     28
       -> ZDSecMgrCtrlAdd               0      0     24
     ZDSecMgrCtrlSet                    1      0     23
     ZDSecMgrCtrlTerm                   2      0      2
       -> ZDSecMgrCtrlLookup            4      0      4
       -> ZDSecMgrCtrlRelease           4      0      4
     ZDSecMgrDeviceCtrlHandler          1      0     42
       -> ZDSecMgrSendMasterKey         0      0     18
       -> ZDSecMgrEstablishKey          0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> osal_start_timerEx            0      0     18
       -> ZDSecMgrCtrlRelease           0      0     18
     ZDSecMgrDeviceCtrlSetup            2      0      0
       -> ZDSecMgrDeviceCtrlHandler     4      0      0
     ZDSecMgrDeviceCtrlUpdate           0      0     13
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     27
       -> ZDSecMgrEntryLookup           0      0     26
       -> ZDSecMgrDeviceEntryRemove     0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrEntryNew              0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
     ZDSecMgrDeviceEntryRemove          2      0     13
       -> ZDSecMgrEntryFree             4      0      0
     ZDSecMgrDeviceJoin                 0      0     24
       -> ZDSecMgrDeviceValidate        0      0     24
       -> ZDSecMgrAddrStore             0      0     28
       -> ZDSecMgrSendNwkKey            0      0     24
       -> ZDSecMgrDeviceRemove          0      0     24
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              2      0      8
       -> APSME_UpdateDeviceReq         4      0     16
     ZDSecMgrDeviceNew                  2      0     35
       -> ZDSecMgrDeviceJoinFwd         4      0      0
     ZDSecMgrDeviceRemove               2      0     40
       -> NLME_GetShortAddr             4      0     42
       -> AssocGetWithExt               0      0     42
       -> NLME_LeaveReq                 0      0     42
       -> APSME_RemoveDeviceReq         0      0     42
     ZDSecMgrDeviceRemoveByExtAddr      0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
       -> ZDSecMgrDeviceEntryRemove     0      0     22
     ZDSecMgrDeviceValidate             2      0     12
       -> ZDSecMgrDeviceValidateRM      4      0      0
     ZDSecMgrDeviceValidateCM           0      0     16
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLoad         0      0     28
       -> ZDSecMgrDeviceEntryAdd        0      0     28
     ZDSecMgrDeviceValidateRM           2      0      0
     ZDSecMgrDeviceValidateSKKE         0      0     42
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  2      0      0
     ZDSecMgrEntryInit                  2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrEntryLookup                0      0     36
       -> AddrMgrEntryLookupNwk         0      0     46
     ZDSecMgrEntryLookupAMI             0      0     26
     ZDSecMgrEntryLookupExt             0      0     25
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrEntryLookupAMI        0      0     22
     ZDSecMgrEntryNew                   0      0     26
     ZDSecMgrEstablishKey               2      0     28
       -> NLME_GetShortAddr             4      0     38
       -> APSME_EstablishKeyReq         0      0     38
     ZDSecMgrEstablishKeyCfm            0      0      0
     ZDSecMgrEstablishKeyInd            1      0     29
       -> ZDSecMgrTCDataLoad            0      0     58
       -> ZDSecMgrTCExtAddrCheck        0      0     58
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     58
       -> APSME_EstablishKeyRsp         0      0     58
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              0      0     38
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryLookupExt         0      0     44
     ZDSecMgrExtAddrStore               0      0     24
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrInit                       2      0      0
       -> ZDSecMgrConfig                4      0      0
     ZDSecMgrMasterKeyInit              2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrMasterKeyLoad              0      0     33
       -> ZDSecMgrExtAddrLookup         0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     32
       -> osal_memcpy                   0      0     38
       -> ZDSecMgrMasterKeyStore        0      0     32
     ZDSecMgrMasterKeyLookup            0      0     35
     ZDSecMgrMasterKeyStore             0      0     34
       -> osal_memset                   0      0     30
       -> osal_memcpy                   0      0     36
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestAppKey              2      0     12
       -> AddrMgrExtAddrLookup          4      0     24
       -> APSME_RequestKeyReq           4      0     24
     ZDSecMgrRequestKeyInd              2      0      0
       -> ZDSecMgrAppKeyReq             4      0      0
     ZDSecMgrSendMasterKey              2      0     34
       -> ZDSecMgrMasterKeyLookup       0      0     50
       -> NLME_GetShortAddr             4      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSendNwkKey                 2      0     37
       -> NLME_GetShortAddr             4      0     50
       -> NLME_GetShortAddr             4      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSetupPartner               0      0     24
       -> AddrMgrExtAddrSet             0      0     48
       -> AddrMgrEntryUpdate            0      0     48
       -> ZDP_NwkAddrReq                0      0     48
       -> AddrMgrExtAddrValid           0      0     48
       -> ZDP_IEEEAddrReq               0      0     48
     ZDSecMgrSwitchKeyInd               2      0      0
       -> SSP_SwitchNwkKey              4      0      0
       -> ZDApp_NVUpdate                4      0      0
     ZDSecMgrTCDataLoad                 0      0     45
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     28
       -> ZDSecMgrMasterKeyStore        0      0     28
     ZDSecMgrTCExtAddrCheck             0      0     46
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     10
       -> ZDSecMgrTCDataLoad            0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> ZDSecMgrAuthNwkKey            0      0     20
     ZDSecMgrUpdateDeviceInd            2      0     10
       -> ZDSecMgrDeviceJoin            4      0     20


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrTCDataLoaded                      1
     ZDSecMgrMasterKeyData                     2
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       32
     ZDSecMgrMasterKeyInit                    99
     ZDSecMgrAddrStore                       126
     ZDSecMgrExtAddrStore                    126
     ZDSecMgrExtAddrLookup                   111
     ZDSecMgrMasterKeyLookup                 126
     ZDSecMgrMasterKeyStore                  182
     ZDSecMgrEntryInit                       111
     ZDSecMgrEntryLookup                     183
     ZDSecMgrEntryLookupAMI                  126
     ZDSecMgrEntryLookupExt                   74
     ZDSecMgrEntryFree                        21
     ZDSecMgrEntryNew                        139
     ZDSecMgrCtrlInit                        100
     ZDSecMgrCtrlRelease                      22
     ZDSecMgrCtrlLookup                      138
     ZDSecMgrCtrlSet                         114
     ZDSecMgrCtrlAdd                         126
     ZDSecMgrCtrlTerm                         63
     ZDSecMgrCtrlReset                       100
     ZDSecMgrMasterKeyLoad                   127
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        63
     ZDSecMgrAppKeyReq                       326
     ZDSecMgrEstablishKey                    180
     ZDSecMgrSendMasterKey                   234
     ZDSecMgrSendNwkKey                      265
     ZDSecMgrDeviceEntryRemove                14
     ZDSecMgrDeviceRemoveByExtAddr            53
     ZDSecMgrAddrMgrUpdate                    93
     ZDSecMgrDeviceEntryAdd                  236
     ZDSecMgrDeviceCtrlHandler               159
     ZDSecMgrDeviceCtrlSetup                  85
     ZDSecMgrDeviceCtrlUpdate                150
     APSME_SKA_TimerExpired                    3
     ZDSecMgrDeviceRemove                    243
     ZDSecMgrDeviceValidateSKKE               95
     ZDSecMgrDeviceValidateRM                 21
     ZDSecMgrDeviceValidateCM                128
     ZDSecMgrDeviceValidate                   52
     ZDSecMgrDeviceJoin                       98
     ZDSecMgrDeviceJoinDirect                 39
     ZDSecMgrDeviceJoinFwd                   197
     ZDSecMgrDeviceNew                        14
     ZDSecMgrAssocDeviceAuth                  28
     ZDSecMgrAuthInitiate                     79
     ZDSecMgrAuthNwkKey                       31
     ZDSecMgrInit                             14
     ZDSecMgrConfig                           14
     ZDSecMgrPermitJoining                    43
     ZDSecMgrPermitJoiningTimeout             28
     ZDSecMgrNewDeviceEvent                  229
     ZDSecMgrEvent                           332
     ZDSecMgrEstablishKeyCfm                   3
     ZDSecMgrTCExtAddrCheck                   69
     ZDSecMgrTCDataLoad                      120
     ZDSecMgrEstablishKeyInd                 286
     ZDSecMgrTransportKeyInd                 158
     ZDSecMgrUpdateDeviceInd                  99
     ZDSecMgrRemoveDeviceInd                 101
     ZDSecMgrRequestKeyInd                    34
     ZDSecMgrSwitchKeyInd                     27
     ZDSecMgrAuthenticateInd                 177
     ZDSecMgrAuthenticateCfm                  55
     ZDSecMgrRequestAppKey                    87
     ZDSecMgrSetupPartner                    137
     APSME_MasterKeyGet                       72
     APSME_LinkKeySet                        138
     ZDSecMgrAuthenticationSet                63
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyDataGet                    105
     APSME_KeyFwdToChild                      74
     ZDSecMgrAddLinkKey                      167
     ZDSecMgrAPSRemove                       105
     APSME_TCLinkKeyInit                     173
     APSME_TCLinkKeySync                     322
     APSME_TCLinkKeyLoad                     343
     APSME_IsDefaultTCLK                      51
     ?<Initializer for ZDSecMgrTCMasterKey>   16
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_1                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrDeviceRemoveByExtAddr?relay     6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrRequestAppKey?relay             6
     ??ZDSecMgrSetupPartner?relay              6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyDataGet?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrAPSRemove?relay                 6
     ??APSME_TCLinkKeyInit?relay               6
     ??APSME_TCLinkKeySync?relay               6
     ??APSME_TCLinkKeyLoad?relay               6
     ??APSME_IsDefaultTCLK?relay               6

 
 8 731 bytes in segment BANKED_CODE
   456 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    50 bytes in segment XDATA_Z
 
 9 204 bytes of CODE  memory
     0 bytes of CONST memory (+ 8 bytes shared)
    67 bytes of XDATA memory

Errors: none
Warnings: none
